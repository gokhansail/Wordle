using System;
using System.Collections.Generic;
using System.Windows.Forms;
using Kitware.VTK;

namespace VTKBoxSelectionApp
{
    public partial class MainForm : Form
    {
        private vtkRenderer renderer;
        private vtkRenderWindow renderWindow;
        private vtkRenderWindowInteractor interactor;
        private vtkAreaPicker areaPicker;
        private List<vtkActor> quadActors = new List<vtkActor>(); // DÃ¶rtgen aktÃ¶rleri
        private List<vtkActor> selectedActors = new List<vtkActor>(); // SeÃ§ili dÃ¶rtgenler

        public MainForm()
        {
            InitializeComponent();
            InitializeVTK();
            InitializeSelection();
        }

        private void InitializeVTK()
        {
            renderWindow = renderWindowControl1.RenderWindow;
            renderer = vtkRenderer.New();
            renderWindow.AddRenderer(renderer);

            // ğŸ”¹ DikdÃ¶rtgen prizmayÄ± 4x4 grid ÅŸeklinde oluÅŸturalÄ±m
            int gridX = 4, gridY = 4;
            double width = 5.0, height = 3.0;

            vtkPoints points = vtkPoints.New();
            vtkCellArray quads = vtkCellArray.New();

            // ğŸ”¹ Grid noktalarÄ±nÄ± oluÅŸtur
            for (int i = 0; i <= gridX; i++)
            {
                for (int j = 0; j <= gridY; j++)
                {
                    points.InsertNextPoint(i * (width / gridX), j * (height / gridY), 0.0);
                }
            }

            // ğŸ”¹ DÃ¶rtgenleri oluÅŸtur (Mesh)
            for (int i = 0; i < gridX; i++)
            {
                for (int j = 0; j < gridY; j++)
                {
                    int p1 = i * (gridY + 1) + j;
                    int p2 = p1 + 1;
                    int p3 = p2 + gridY;
                    int p4 = p3 + 1;

                    vtkQuad quad = vtkQuad.New();
                    quad.GetPointIds().SetId(0, p1);
                    quad.GetPointIds().SetId(1, p2);
                    quad.GetPointIds().SetId(2, p4);
                    quad.GetPointIds().SetId(3, p3);

                    quads.InsertNextCell(quad);
                }
            }

            // ğŸ”¹ PolyData oluÅŸtur
            vtkPolyData polyData = vtkPolyData.New();
            polyData.SetPoints(points);
            polyData.SetPolys(quads);

            // ğŸ”¹ Mesh iÃ§in her dÃ¶rtgeni ayrÄ± bir actor olarak oluÅŸtur
            for (int i = 0; i < quads.GetNumberOfCells(); i++)
            {
                vtkCellArray singleQuad = vtkCellArray.New();
                singleQuad.InsertNextCell(quads.GetCell(i));

                vtkPolyData singlePolyData = vtkPolyData.New();
                singlePolyData.SetPoints(points);
                singlePolyData.SetPolys(singleQuad);

                vtkPolyDataMapper mapper = vtkPolyDataMapper.New();
                mapper.SetInput(singlePolyData);

                vtkActor actor = vtkActor.New();
                actor.SetMapper(mapper);
                actor.GetProperty().SetColor(1.0, 0.0, 0.0); // BaÅŸlangÄ±Ã§ta kÄ±rmÄ±zÄ±

                quadActors.Add(actor);
                renderer.AddActor(actor);
            }

            // ğŸ”¹ Nodelar iÃ§in kÃ¼Ã§Ã¼k kÃ¼reler ekleyelim
            for (int i = 0; i < points.GetNumberOfPoints(); i++)
            {
                double[] p = points.GetPoint(i);

                vtkSphereSource sphereSource = vtkSphereSource.New();
                sphereSource.SetRadius(0.05);
                sphereSource.SetCenter(p[0], p[1], p[2]);
                sphereSource.Update();

                vtkPolyDataMapper sphereMapper = vtkPolyDataMapper.New();
                sphereMapper.SetInputConnection(sphereSource.GetOutputPort());

                vtkActor sphereActor = vtkActor.New();
                sphereActor.SetMapper(sphereMapper);
                sphereActor.GetProperty().SetColor(0.0, 1.0, 0.0); // YeÅŸil nodelar

                renderer.AddActor(sphereActor);
            }

            renderer.SetBackground(0.2, 0.3, 0.4);
            renderer.ResetCamera();
        }

        private void InitializeSelection()
        {
            interactor = renderWindow.GetInteractor();
            areaPicker = vtkAreaPicker.New();
            interactor.SetPicker(areaPicker);

            // ğŸ”¹ Mouse SeÃ§im OlaylarÄ±
            interactor.LeftButtonPressEvt += OnLeftButtonPress;
            interactor.RightButtonPressEvt += OnRightButtonPress;
        }

        private void OnLeftButtonPress(vtkObject sender, vtkObjectEventArgs e)
        {
            int[] clickPos = interactor.GetEventPosition();
            areaPicker.AreaPick(clickPos[0] - 10, clickPos[1] - 10, clickPos[0] + 10, clickPos[1] + 10, renderer);

            vtkActor selectedActor = areaPicker.GetActor();
            if (selectedActor != null)
            {
                if (!selectedActors.Contains(selectedActor))
                {
                    selectedActor.GetProperty().SetColor(0.0, 1.0, 0.0); // SeÃ§ili yÃ¼zey yeÅŸil olur
                    selectedActors.Add(selectedActor);
                }
                renderWindow.Render();
            }
        }

        private void OnRightButtonPress(vtkObject sender, vtkObjectEventArgs e)
        {
            // ğŸ”¹ SaÄŸ tÄ±klamada seÃ§imleri sÄ±fÄ±rla
            foreach (var actor in selectedActors)
            {
                actor.GetProperty().SetColor(1.0, 0.0, 0.0); // KÄ±rmÄ±zÄ±ya geri dÃ¶n
            }
            selectedActors.Clear();
            renderWindow.Render();
        }

        private void MainForm_Load(object sender, EventArgs e)
        {
            renderWindowControl1.RenderWindow.Render();
        }
    }
}


using System;
using System.Windows.Forms;
using Kitware.VTK;

public class VTKBoxSelectionForm : Form
{
    private RenderWindowControl renderWindowControl;
    private vtkRenderer renderer;
    private vtkRenderWindow renderWindow;
    private vtkRenderWindowInteractor interactor;
    private vtkAreaPicker areaPicker;

    public VTKBoxSelectionForm()
    {
        // VTK Render KontrolÃ¼nÃ¼ baÅŸlat
        renderWindowControl = new RenderWindowControl
        {
            Dock = DockStyle.Fill
        };
        this.Controls.Add(renderWindowControl);

        InitializeVTK();
        InitializeSelection();
    }

    private void InitializeVTK()
    {
        // Render Window ve Renderer oluÅŸtur
        renderWindow = renderWindowControl.RenderWindow;
        renderer = vtkRenderer.New();
        renderWindow.AddRenderer(renderer);

        // Ã–rnek olarak birkaÃ§ Ã¼Ã§gen ekleyelim
        vtkPoints points = vtkPoints.New();
        points.InsertNextPoint(0.0, 0.0, 0.0);
        points.InsertNextPoint(1.0, 0.0, 0.0);
        points.InsertNextPoint(0.5, 1.0, 0.0);

        vtkTriangle triangle = vtkTriangle.New();
        triangle.GetPointIds().SetId(0, 0);
        triangle.GetPointIds().SetId(1, 1);
        triangle.GetPointIds().SetId(2, 2);

        vtkCellArray triangles = vtkCellArray.New();
        triangles.InsertNextCell(triangle);

        vtkPolyData polyData = vtkPolyData.New();
        polyData.SetPoints(points);
        polyData.SetPolys(triangles);

        vtkPolyDataMapper mapper = vtkPolyDataMapper.New();
        mapper.SetInput(polyData);

        vtkActor actor = vtkActor.New();
        actor.SetMapper(mapper);
        actor.GetProperty().SetColor(1.0, 0.0, 0.0); // KÄ±rmÄ±zÄ± renk

        renderer.AddActor(actor);
        renderer.SetBackground(0.2, 0.3, 0.4);
        renderer.ResetCamera();
    }

    private void InitializeSelection()
    {
        // Interactor (KullanÄ±cÄ± etkileÅŸimi) baÅŸlat
        interactor = renderWindow.GetInteractor();

        // vtkAreaPicker ile seÃ§im alanÄ± belirleme
        areaPicker = vtkAreaPicker.New();
        interactor.SetPicker(areaPicker);

        // Mouse EtkinliÄŸi Ä°Ã§in Olay BaÄŸlantÄ±sÄ±
        interactor.LeftButtonPressEvt += OnLeftButtonPress;
    }

    private void OnLeftButtonPress(vtkObject sender, vtkObjectEventArgs e)
    {
        int[] clickPos = interactor.GetEventPosition();

        // SeÃ§im iÅŸlemini baÅŸlat
        areaPicker.AreaPick(clickPos[0] - 10, clickPos[1] - 10, clickPos[0] + 10, clickPos[1] + 10, renderer);

        vtkActor selectedActor = areaPicker.GetActor();
        if (selectedActor != null)
        {
            selectedActor.GetProperty().SetColor(0.0, 1.0, 0.0); // YeÅŸil renge Ã§evir (SeÃ§ili olduÄŸunu gÃ¶ster)
            renderWindow.Render();
            Console.WriteLine("Element seÃ§ildi!");
        }
        else
        {
            Console.WriteLine("HiÃ§bir element seÃ§ilmedi.");
        }
    }

    [STAThread]
    static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        Application.Run(new VTKBoxSelectionForm());
    }
}

using System;
using System.Windows.Forms;
using Kitware.VTK;

public class VTKBoxSelectionForm : Form
{
    private RenderWindowControl renderWindowControl;
    private vtkRenderer renderer;
    private vtkRenderWindow renderWindow;
    private vtkRenderWindowInteractor interactor;
    private vtkHardwareSelector selector;

    public VTKBoxSelectionForm()
    {
        // VTK Render KontrolÃ¼nÃ¼ baÅŸlat
        renderWindowControl = new RenderWindowControl
        {
            Dock = DockStyle.Fill
        };
        this.Controls.Add(renderWindowControl);

        InitializeVTK();
        InitializeSelection();
    }

    private void InitializeVTK()
    {
        // Render Window ve Renderer oluÅŸtur
        renderWindow = renderWindowControl.RenderWindow;
        renderer = vtkRenderer.New();
        renderWindow.AddRenderer(renderer);

        // Ã–rnek olarak birkaÃ§ Ã¼Ã§gen ekleyelim
        vtkPoints points = vtkPoints.New();
        points.InsertNextPoint(0.0, 0.0, 0.0);
        points.InsertNextPoint(1.0, 0.0, 0.0);
        points.InsertNextPoint(0.5, 1.0, 0.0);

        vtkTriangle triangle = vtkTriangle.New();
        triangle.GetPointIds().SetId(0, 0);
        triangle.GetPointIds().SetId(1, 1);
        triangle.GetPointIds().SetId(2, 2);

        vtkCellArray triangles = vtkCellArray.New();
        triangles.InsertNextCell(triangle);

        vtkPolyData polyData = vtkPolyData.New();
        polyData.SetPoints(points);
        polyData.SetPolys(triangles);

        vtkPolyDataMapper mapper = vtkPolyDataMapper.New();
        mapper.SetInput(polyData);

        vtkActor actor = vtkActor.New();
        actor.SetMapper(mapper);
        renderer.AddActor(actor);

        renderer.SetBackground(0.2, 0.3, 0.4);
        renderer.ResetCamera();
    }

    private void InitializeSelection()
    {
        // Interactor (KullanÄ±cÄ± etkileÅŸimi) baÅŸlat
        interactor = renderWindow.GetInteractor();

        // Hardware Selector ayarÄ±
        selector = vtkHardwareSelector.New();
        selector.SetRenderer(renderer);

        // Mouse EtkinliÄŸi Ä°Ã§in Olay BaÄŸlantÄ±sÄ±
        interactor.LeftButtonPressEvt += OnLeftButtonPress;
    }

    private void OnLeftButtonPress(vtkObject sender, vtkObjectEventArgs e)
    {
        int[] clickPos = interactor.GetEventPosition();

        selector.SetArea(clickPos[0] - 5, clickPos[1] - 5, clickPos[0] + 5, clickPos[1] + 5);
        selector.SetFieldAssociation(vtkDataObject.FIELD_ASSOCIATION_CELLS);
        
        vtkSelection selection = selector.Select();
        if (selection.GetNumberOfNodes() > 0)
        {
            Console.WriteLine("SeÃ§im baÅŸarÄ±lÄ±! YalnÄ±zca ekrandaki gÃ¶rÃ¼nen elementler seÃ§ildi.");
        }
        else
        {
            Console.WriteLine("HiÃ§bir element seÃ§ilmedi.");
        }
    }

    [STAThread]
    static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        Application.Run(new VTKBoxSelectionForm());
    }
}


Kitware.VTK;

public class VTKTriangleForm

using System;
using System.Windows.Forms;
using  : Form
{
    private RenderWindowControl renderWindowControl;

    public VTKTriangleForm()
    {
        renderWindowControl = new RenderWindowControl
        {
            Dock = DockStyle.Fill
        };
        this.Controls.Add(renderWindowControl);
        InitializeVTK();
    }

    private void InitializeVTK()
    {
        // 1ï¸âƒ£ VTK RenderWindow ve Renderer oluÅŸtur
        vtkRenderWindow renderWindow = renderWindowControl.RenderWindow;
        vtkRenderer renderer = vtkRenderer.New();
        renderWindow.AddRenderer(renderer);

        // 2ï¸âƒ£ ÃœÃ§genin kÃ¶ÅŸe noktalarÄ±nÄ± tanÄ±mla
        vtkPoints points = vtkPoints.New();
        points.InsertNextPoint(0.0, 0.0, 0.0);  // Nokta 0
        points.InsertNextPoint(1.0, 0.0, 0.0);  // Nokta 1
        points.InsertNextPoint(0.5, 1.0, 0.0);  // Nokta 2

        // 3ï¸âƒ£ ÃœÃ§gen oluÅŸtur
        vtkTriangle triangle = vtkTriangle.New();
        triangle.GetPointIds().SetId(0, 0);
        triangle.GetPointIds().SetId(1, 1);
        triangle.GetPointIds().SetId(2, 2);

        // 4ï¸âƒ£ ÃœÃ§geni iÃ§eren bir hÃ¼cre (cell) dizisi oluÅŸtur
        vtkCellArray triangles = vtkCellArray.New();
        triangles.InsertNextCell(triangle);

        // 5ï¸âƒ£ PolyData nesnesi oluÅŸtur ve noktalar ile Ã¼Ã§geni ekle
        vtkPolyData polyData = vtkPolyData.New();
        polyData.SetPoints(points);
        polyData.SetPolys(triangles);

        // 6ï¸âƒ£ Mapper ve Actor oluÅŸtur
        vtkPolyDataMapper mapper = vtkPolyDataMapper.New();
        mapper.SetInput(polyData);

        vtkActor actor = vtkActor.New();
        actor.SetMapper(mapper);
        actor.GetProperty().SetColor(1.0, 0.0, 0.0); // KÄ±rmÄ±zÄ± renk

        // 7ï¸âƒ£ Renderer'a Ã¼Ã§geni ekleyip sahneyi gÃ¶ster
        renderer.AddActor(actor);
        renderer.SetBackground(0.2, 0.3, 0.4); // Arka plan rengi (mavi tonlarÄ±)
        renderer.ResetCamera();
    }

    [STAThread]
    static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        Application.Run(new VTKTriangleForm());
    }
}




1. Genel Kodlama StandartlarÄ±
	â€¢	Girintileme ve SatÄ±r FormatÄ±: TÃ¼m girintiler 4 boÅŸluk karakteri ile yapÄ±lmalÄ±, sekme (tab) karakteri kullanÄ±lmamalÄ±dÄ±r ï¿¼. Kod bloklarÄ± ve alt bloklar tutarlÄ± ÅŸekilde hizalanmalÄ±; uzun satÄ±rlar okunabilirlik iÃ§in genelde 100 karakteri geÃ§memelidir ï¿¼. Her bir kod satÄ±rÄ±nda en fazla bir ifade bulunmalÄ±, bir satÄ±rda birden fazla komut veya tanÄ±m tanÄ±mlanmamalÄ±dÄ±r ï¿¼.
	â€¢	KÃ¶ÅŸeli Parantez (Brace) Stili: C#â€™ta yaygÄ±n olarak Allman stili benimsenmelidir: AÃ§ma { ve kapama } sÃ¼slÃ¼ parantezleri kendi satÄ±rlarÄ±nda olmalÄ±, mevcut blok girintisi hizasÄ±nda konumlanmalÄ±dÄ±r ï¿¼. Tek satÄ±rlÄ±k if/else gibi yapÄ±lar dahi sÃ¼slÃ¼ parantez iÃ§inde yazÄ±lmalÄ±dÄ±r (ileride kod geniÅŸleyebileceÄŸi iÃ§in). AyrÄ±ca, if-else/try-catch bloklarÄ±nda kapanan parantez ile sonraki anahtar kelime (else/catch gibi) aynÄ± satÄ±ra yazÄ±lmamalÄ±dÄ±r.
	â€¢	BoÅŸluk KullanÄ±mÄ±: Anahtar kelimelerden sonra ve virgÃ¼llerden sonra bir boÅŸluk bÄ±rakÄ±n (Ã¶r. if ( koÅŸul baÅŸlamadan Ã¶nce boÅŸluk) ï¿¼. AÃ§Ä±lan parantezden hemen sonra veya kapanan parantezden Ã¶nce boÅŸluk koymayÄ±n ï¿¼. Tek operandâ€™lÄ± (unary) operatÃ¶rlerle operand arasÄ±nda boÅŸluk olmaz (-x, !flag gibi), ancak diÄŸer tÃ¼m ikili operatÃ¶rlerin (+, == vb.) her iki tarafÄ±nda birer boÅŸluk olmalÄ±dÄ±r ï¿¼. Bu kurallar kodun daha temiz ve tutarlÄ± gÃ¶rÃ¼nmesini saÄŸlar.
	â€¢	BoÅŸ SatÄ±rlar: MantÄ±ksal bloklarÄ± ayÄ±rmak ve okunabilirliÄŸi artÄ±rmak iÃ§in uygun yerde boÅŸ satÄ±r bÄ±rakÄ±n. Ã–zellikle, yÃ¶ntemler ve Ã¶zellikler (property) arasÄ±nda en az bir boÅŸ satÄ±r olmasÄ±na Ã¶zen gÃ¶sterin ï¿¼. Benzer ÅŸekilde, bir sÄ±nÄ±f iÃ§erisindeki alanlar, metotlar, Ã¶zellikler gruplanÄ±rken aralara boÅŸ satÄ±rlar konulmasÄ± kodun bÃ¶lÃ¼mlerini gÃ¶rsel olarak ayÄ±rarak anlaÅŸÄ±labilirliÄŸi artÄ±rÄ±r.
	â€¢	Yorum SatÄ±rlarÄ±: AnlaÅŸÄ±lÄ±r yorumlar yazmak iyi bir pratiktir. KÄ±sa aÃ§Ä±klamalar iÃ§in // tek satÄ±r yorum kullanÄ±n; uzun aÃ§Ä±klamalar gerekiyorsa mÃ¼mkÃ¼nse birden fazla // satÄ±rÄ± ÅŸeklinde yazÄ±n veya gerektiÄŸinde /* ... */ Ã§ok satÄ±rlÄ± yorum bloÄŸunu tercih edin ï¿¼. YorumlarÄ± mÃ¼mkÃ¼nse bir kod satÄ±rÄ±nÄ±n sonuna deÄŸil, ayrÄ± bir satÄ±ra koyun ï¿¼. // yorumlarÄ±nda imleÃ§ ile yorum metni arasÄ±nda bir boÅŸluk bÄ±rakÄ±n ve yorum metnine bÃ¼yÃ¼k harfle baÅŸlayÄ±p nokta (.) ile sonlandÄ±rÄ±n ï¿¼. AyrÄ±ca, Ã¶zellikle public API Ã¼yeleri iÃ§in XML yorumlarÄ± (///) kullanÄ±n ki bu aÃ§Ä±klamalar IntelliSenseâ€™de gÃ¶rÃ¼nerek dokÃ¼mantasyon iÅŸlevi gÃ¶rsÃ¼n ï¿¼.
	â€¢	Kod DÃ¼zenlemesi: Kod okunabilirliÄŸini artÄ±rmak iÃ§in ifadelerde gerekirse parantez kullanÄ±n. Ã–zellikle karmaÅŸÄ±k koÅŸullarda her bir koÅŸulu parantez iÃ§ine almak, Ã¶nceliklerin anlaÅŸÄ±lmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r ï¿¼. Uzun ifadeleri birden fazla satÄ±ra bÃ¶lmeniz gerekiyorsa, operatÃ¶rleri yeni satÄ±rÄ±n baÅŸÄ±na alarak hizalÄ± bir gÃ¶rÃ¼nÃ¼m elde edin.

2. Ä°simlendirme KurallarÄ±
	â€¢	Genel Ä°simlendirme Stili: .NET ekosisteminde yazÄ±lan kodlarda PascalCase ve camelCase standartlarÄ± kullanÄ±lÄ±r ï¿¼. SÄ±nÄ±f, metot, property ve public field isimleri PascalCase (HerKelimeninÄ°lkHarfiBÃ¼yÃ¼k) stilinde olmalÄ±dÄ±r ï¿¼ ï¿¼. Yerel deÄŸiÅŸkenler ve metot parametreleri ise camelCase (ilk harf kÃ¼Ã§Ã¼k, takip eden kelimeler bÃ¼yÃ¼k) stilinde yazÄ±lmalÄ±dÄ±r ï¿¼.
	â€¢	SÄ±nÄ±f, YapÄ± ve Arabirim Ä°simleri: SÄ±nÄ±f ve struct isimleri aÃ§Ä±k ve anlamlÄ± olmalÄ±, PascalCase kullanÄ±lmalÄ±dÄ±r ï¿¼. Arabirim (interface) isimleri I harfi ile baÅŸlamalÄ±dÄ±r (Ã¶r. ILogger, IDataService), bu standart arayÃ¼zleri hÄ±zlÄ± tanÄ±mamÄ±zÄ± saÄŸlar ï¿¼. Enum tipleri, eÄŸer bir bayrak koleksiyonu (Flags) deÄŸilse tekil isimle anÄ±lmalÄ±, Flags olarak kullanÄ±lacaksa Ã§oÄŸul isim verilmelidir ï¿¼.
	â€¢	DeÄŸiÅŸken ve Alan Ä°simleri: DeÄŸiÅŸken adlarÄ±, taÅŸÄ±dÄ±klarÄ± anlama uygun, aÃ§Ä±klayÄ±cÄ± kelimelerden oluÅŸmalÄ±dÄ±r ï¿¼. Yerel deÄŸiÅŸkenler ve parametreler camelCase stilinde yazÄ±lÄ±rken, Ã¶zel (private) alan isimleri _ karakteri ile baÅŸlamalÄ± ve sonrasÄ±nda camelCase devam etmelidir (Ã¶r. _customerRepository) ï¿¼. Bu, alanlarÄ± diÄŸer deÄŸiÅŸkenlerden kolayca ayÄ±rt etmeyi saÄŸlar. Statik alanlar iÃ§in benzer ÅŸekilde s_ Ã¶neki kullanÄ±labilir (Ã¶r. s_cache) ï¿¼.
	â€¢	Sabitler ve Enum DeÄŸerleri: const veya readonly olarak tanÄ±mlanan sabit deÄŸerler de PascalCase ile adlandÄ±rÄ±lmalÄ±dÄ±r ï¿¼. C dilindeki gibi BÃœYÃœK HARFLE â€œScreaming Capsâ€ stilinde sabit isimlendirmeden kaÃ§Ä±nÄ±lmalÄ±dÄ±r ï¿¼. Ã–rneÄŸin MaxItems uygun iken MAX_ITEMS ya da MAXITEMS tercih edilmez. Bu sayede sabitler de diÄŸer Ã¼yelerle tutarlÄ± bir gÃ¶rÃ¼nÃ¼me sahip olur.
	â€¢	AnlamlÄ± ve TutarlÄ± Ä°simler: Ä°simlendirmede kÄ±saltmalardan kaÃ§Ä±nÄ±n; Ã¶zellikle ekip iÃ§inde anlaÅŸÄ±lmayabilecek kÄ±saltmalar kodun bakÄ±mÄ±nÄ± zorlaÅŸtÄ±rÄ±r ï¿¼. Sadece genel kabul gÃ¶rmÃ¼ÅŸ kÄ±saltmalar gerekiyorsa kullanÄ±labilir (Ã¶r. Http, XML, UID). Bu tÃ¼r kÄ±saltmalarda da 2 harfli olanlar bÃ¼yÃ¼k harflerle (IO), 3 veya daha fazla harften oluÅŸanlar PascalCase iÃ§inde normal kelime gibi (XmlDocument, SqlConnection) yazÄ±lÄ±r ï¿¼.
	â€¢	Ä°simlendirmede YanlÄ±ÅŸ Uygulamalardan KaÃ§Ä±nma: Hungarian notation (deÄŸiÅŸken adÄ±nda tÃ¼r belirtme, Ã¶r. strName, iCount gibi) kullanÄ±lmamalÄ±dÄ±r ï¿¼ â€“ modern IDE ve derleyiciler tÃ¼r bilgisini zaten saÄŸladÄ±ÄŸÄ± iÃ§in bu gereksizdir. Ä°simlerde birden fazla alt tire (__) kullanmaktan kaÃ§Ä±nÄ±n; iki alt tire kombinasyonlarÄ± derleyici tarafÄ±ndan Ã¶zel isimler iÃ§in kullanÄ±labilir ï¿¼. AyrÄ±ca, Ã§ok genel tek harfli deÄŸiÅŸken adlarÄ± kullanÄ±lmamalÄ±; yalnÄ±zca dÃ¶ngÃ¼ sayaÃ§larÄ±nda i, j, k gibi anlamÄ± geleneksel olarak anlaÅŸÄ±lan harfler tek harf olarak kabul edilebilir ï¿¼.

3. Kod DÃ¼zeni ve YapÄ±sÄ±
	â€¢	Using ve Namespace DÃ¼zeni: using yÃ¶nergeleri dosyanÄ±n baÅŸÄ±nda, namespace tanÄ±mÄ±ndan Ã¶nce yer almalÄ±dÄ±r. Ä°mkan varsa using ifadelerini alfabetik olarak sÄ±ralayÄ±n; ayrÄ±ca genellikle System ile baÅŸlayan usingâ€™ler en Ã¼stte tutulur ï¿¼. ArdÄ±ndan proje/uygulama kapsamÄ±ndaki diÄŸer namespace importlarÄ± gelir.
	â€¢	Namespace Organizasyonu: Namespace isimleri, projeyi yansÄ±tan hiyerarÅŸik bir yapÄ±da ve PascalCase stilde olmalÄ±dÄ±r (Ã¶r. SirketAdi.ProjeAdi.ModulAdi). Ä°simler anlamlÄ± ve tanÄ±mlayÄ±cÄ± seÃ§ilmeli, mÃ¼mkÃ¼nse ÅŸirket alan adÄ±na gÃ¶re ters ÅŸekilde organize edilmelidir (Ã¶r. Com.Contoso.eCommerce.OrderService) ï¿¼. Dosya sistemi (klasÃ¶rler) ile namespace hiyerarÅŸisi paralel tutulursa, doÄŸru dosyada doÄŸru kodu bulmak kolaylaÅŸÄ±r.
	â€¢	Dosya BaÅŸÄ±na Tek SÄ±nÄ±f: Her bir C# kod dosyasÄ±nda mÃ¼mkÃ¼nse yalnÄ±zca bir tane public tÃ¼r tanÄ±mlayÄ±n (sÄ±nÄ±f, arayÃ¼z, enum vb.) ï¿¼. Dosya adÄ±, iÃ§erdiÄŸi ana sÄ±nÄ±f veya yapÄ±nÄ±n adÄ±yla birebir aynÄ± olmalÄ±dÄ±r (Ã¶rn. CustomerService.cs iÃ§inde public class CustomerService) ï¿¼. Bu kural, dosya bazÄ±nda sÃ¼rÃ¼m kontrolÃ¼nÃ¼ ve kodun bulunmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. (Ä°stisna olarak, bir sÄ±nÄ±fÄ±n partial parÃ§alarÄ± veya o sÄ±nÄ±fa ait iÃ§ iÃ§e tipler aynÄ± dosyada olabilir.) ï¿¼
	â€¢	SÄ±nÄ±f Ä°Ã§i Ãœye SÄ±ralamasÄ±: Bir sÄ±nÄ±f iÃ§indeki Ã¼yelerin tutarlÄ± bir sÄ±rayla yerleÅŸtirilmesi okunabilirliÄŸi artÄ±rÄ±r. Ã–nerilen bir sÄ±ralama: Ã–nce iÃ§ iÃ§e tanÄ±mlÄ± sÄ±nÄ±f, enum, delegete ve eventâ€™ler; ardÄ±ndan sabit (const) ve statik (static) alanlar; sonra Ã¶rnek alanlar; Ã¶zellikler; kurucu (constructor) ve destructor/yÄ±kÄ±cÄ±lar; en son da metotlar ï¿¼. Her bir grup iÃ§inde de Ã¼yeleri eriÅŸim belirtecine gÃ¶re sÄ±ralayÄ±n (Ã¶nce public, sonra internal, protected internal, protected ve son olarak private) ï¿¼. Bu dÃ¼zen, kod okuyucusunun sÄ±nÄ±fÄ±n yapÄ±sÄ±nÄ± hÄ±zlÄ±ca kavramasÄ±nÄ± saÄŸlar.
	â€¢	Proje ve Ã‡Ã¶zÃ¼m Organizasyonu: BÃ¼yÃ¼k projelerde kod, katmanlara veya iÅŸlevsel alt modÃ¼llere ayrÄ±lmalÄ±dÄ±r. Ã–rneÄŸin, ayrÄ± bir veri eriÅŸim katmanÄ± (Repository veya DAL), ayrÄ± bir iÅŸ mantÄ±ÄŸÄ± katmanÄ± ve ayrÄ± bir UI veya API katmanÄ± projeleri ÅŸeklinde organize edilebilir. Her proje kendi sorumluluÄŸuna uygun sÄ±nÄ±flarÄ± iÃ§erirken, ortak kodlar paylaÅŸÄ±lan kÃ¼tÃ¼phanelere alÄ±nmalÄ±dÄ±r. Assembly (derleme) adlarÄ±nÄ± da amacÄ±nÄ± belli edecek ÅŸekilde seÃ§in ï¿¼. Bu sayede Ã§Ã¶zÃ¼m genelinde tutarlÄ± bir modÃ¼ler yapÄ± korunur.

4. Metot ve SÄ±nÄ±f TasarÄ±mÄ± (SOLID Ä°lkeleri)
	â€¢	Single Responsibility (Tek Sorumluluk) Prensibi: Her sÄ±nÄ±f veya metodun tek bir sorumluluÄŸu olmalÄ±dÄ±r. BaÅŸka bir deyiÅŸle, deÄŸiÅŸmek iÃ§in tek bir nedeni olmalÄ±dÄ±r ï¿¼. Bir sÄ±nÄ±f birden fazla iÅŸi yapmaya Ã§alÄ±ÅŸÄ±yorsa bakÄ±m zorlaÅŸÄ±r; sÄ±nÄ±flarÄ±nÄ±zÄ± daha kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lÃ¼p her birini belirli bir iÅŸ iÃ§in uzmanlaÅŸtÄ±rÄ±n. Ã–rneÄŸin, bir sÄ±nÄ±f hem veritabanÄ± iÅŸlemlerini hem de iÅŸ mantÄ±ÄŸÄ±nÄ± yapÄ±yorsa iki ayrÄ± sÄ±nÄ±fa ayrÄ±lmalÄ±dÄ±r.
	â€¢	Open/Closed (AÃ§Ä±k/KapalÄ±) Prensibi: Kodunuz yeni Ã¶zellikler eklemeye aÃ§Ä±k, ancak mevcut davranÄ±ÅŸÄ± deÄŸiÅŸtirmeye kapalÄ± olmalÄ±dÄ±r. Yani var olan sÄ±nÄ±flarÄ± deÄŸiÅŸtirmek zorunda kalmaksÄ±zÄ±n yeni iÅŸlevsellik ekleyebilmelisiniz ï¿¼. Bunu saÄŸlamak iÃ§in sÄ±nÄ±flarÄ±nÄ±zÄ± soyutlayÄ±n ve geniÅŸletilebilir hale getirin (Ã¶rn. arabirimler veya abstract sÄ±nÄ±flar ile temel davranÄ±ÅŸÄ± tanÄ±mlayÄ±p, yeni sÄ±nÄ±flarla geniÅŸletme yapÄ±n). Mevcut kodu deÄŸiÅŸtirmek, yeni hatalar riskini artÄ±rÄ±r; bunun yerine miras alma veya yeni sÄ±nÄ±flar oluÅŸturma yoluyla geniÅŸleme tercih edilmelidir.
	â€¢	Liskov Substitution (Yerine GeÃ§me) Prensibi: TÃ¼retilmiÅŸ (subclass) sÄ±nÄ±flar, her zaman temel sÄ±nÄ±flarÄ±n yerini alabilecek ÅŸekilde davranmalÄ±dÄ±r. Teknik ifade ile, eÄŸer S sÄ±nÄ±fÄ± T sÄ±nÄ±fÄ±nÄ±n bir alt tÃ¼rÃ¼ ise, programda T tipinin beklendiÄŸi her yerde S kullanÄ±labilmeli ve programÄ±n doÄŸruluÄŸu bozulmamalÄ±dÄ±r ï¿¼. Bu prensip, miras hiyerarÅŸilerinde tutarlÄ±lÄ±ÄŸÄ± saÄŸlar. Alt sÄ±nÄ±flar, base sÄ±nÄ±fÄ±n sÃ¶zleÅŸmesini ihlal edecek davranÄ±ÅŸlar eklememelidir. Ã–rneÄŸin, bir alt sÄ±nÄ±f base sÄ±nÄ±ftaki bir metodu etkisiz hale getirmemeli veya anlamsal olarak farklÄ± Ã§alÄ±ÅŸtÄ±rmamalÄ±dÄ±r.
	â€¢	Interface Segregation (ArayÃ¼z AyrÄ±mÄ±) Prensibi: KullanÄ±lmayan metotlarÄ± iÃ§eren bÃ¼yÃ¼k arayÃ¼zler tanÄ±mlamaktan kaÃ§Ä±nÄ±n. MÃ¼mkÃ¼n olduÄŸunca spesifik ve kÃ¼Ã§Ã¼k arayÃ¼zler oluÅŸturun; bÃ¶ylece sÄ±nÄ±flar gereksiz metotlara baÄŸÄ±mlÄ± kalmaz ï¿¼. Prensip, â€œHiÃ§bir istemci kullanmadÄ±ÄŸÄ± bir yÃ¶nteme baÄŸÄ±mlÄ± olmaya zorlanmamalÄ±dÄ±râ€ der. Ã–rneÄŸin, tek bir geniÅŸ arayÃ¼z yerine, ilgili Ã¼yeleri gruplandÄ±ran birden fazla dar arayÃ¼z tanÄ±mlamak, implementasyonlarÄ±n ihtiyacÄ± olmayan Ã¼yeleri gÃ¶rmezden gelmesini engeller. Bu yaklaÅŸÄ±m, kodunuzun baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± azaltÄ±r ve deÄŸiÅŸiklik durumunda etkiyi en aza indirir.
	â€¢	Dependency Inversion (BaÄŸÄ±mlÄ±lÄ±klarÄ± Ters Ã‡evirme) Prensibi: YÃ¼ksek seviye modÃ¼ller (sÄ±nÄ±flar), dÃ¼ÅŸÃ¼k seviye modÃ¼llere direkt baÄŸÄ±mlÄ± olmamalÄ±dÄ±r; her ikisi de abstractions (soyutlamalar) Ã¼zerine baÄŸÄ±mlÄ± olmalÄ±dÄ±r ï¿¼. Yani, somut sÄ±nÄ±flar yerine arabirimler veya abstract sÄ±nÄ±flar Ã¼zerinden baÄŸÄ±mlÄ±lÄ±k tanÄ±mlayÄ±n. Bu prensip, baÄŸÄ±mlÄ±lÄ±k enjeksiyonu (DI) deseninin temelini oluÅŸturur. Ã–rneÄŸin, bir sÄ±nÄ±f bir veritabanÄ± eriÅŸim sÄ±nÄ±fÄ±nÄ± doÄŸrudan Ã§aÄŸÄ±rmak yerine bir arayÃ¼z (Ã¶rn. IDataRepository) Ã¼zerinden Ã§alÄ±ÅŸÄ±rsa, alt katmanlarÄ± deÄŸiÅŸtirmek (farklÄ± bir veri kaynaÄŸÄ±na geÃ§mek gibi) daha az kod deÄŸiÅŸikliÄŸiyle mÃ¼mkÃ¼n olacaktÄ±r.

5. Exception Handling (Hata YÃ¶netimi)
	â€¢	Spesifik HatalarÄ± Yakalama: Hata yakalama bloklarÄ±nda mÃ¼mkÃ¼n olduÄŸunca belirli exception tiplerini yakalamaya Ã¶zen gÃ¶sterin. try/catch kullanÄ±rken, Ã¶nce Ã¶zel durum sÄ±nÄ±flarÄ±nÄ± (Ã¶rn. IOException, SqlException) yakalayÄ±n, en son genel Exception yakalayacak blok varsa tanÄ±mlayÄ±n ï¿¼. Bu sayede beklenen hatalar kontrollÃ¼ ÅŸekilde ele alÄ±nÄ±r. UygulamanÄ±zÄ±n toparlanamayacaÄŸÄ± bir durum oluÅŸtuÄŸunda (Ã¶rneÄŸin belleÄŸin tÃ¼kenmesi), bu istisnalarÄ± yakalamayÄ±p Ã¼st katmana bÄ±rakmak daha doÄŸrudur. Genel kural: YakalayamayacaÄŸÄ±nÄ±z veya anlamlÄ± bir ÅŸekilde iÅŸleyemeyeceÄŸiniz exceptionâ€™larÄ± yakalamayÄ±n ï¿¼ ï¿¼.
	â€¢	KaynaklarÄ±n Serbest BÄ±rakÄ±lmasÄ±: Hata olsa da olmasa da sistem kaynaklarÄ±nÄ±n dÃ¼zgÃ¼n salÄ±ndÄ±ÄŸÄ±ndan emin olun. Bunun iÃ§in finally bloklarÄ±nÄ± veya using yapÄ±sÄ±nÄ± kullanÄ±n. Ã–rneÄŸin, bir dosya okuma iÅŸlemi yaparken dosyayÄ± kapatmak iÃ§in using (var file = File.Open(...)) { ... } deseni takip edilmelidir ï¿¼. finally bloÄŸu, ister hata atsÄ±n ister atmasÄ±n, her durumda Ã§alÄ±ÅŸacaÄŸÄ± iÃ§in kaynak temizliÄŸi (dosya kapama, bellek boÅŸaltma vb.) iÃ§in idealdir.
	â€¢	Exception ile Kontrol AkÄ±ÅŸÄ± Yapmama: HatalarÄ± normal akÄ±ÅŸÄ±n bir parÃ§asÄ± olarak kullanmayÄ±n. Ã–ngÃ¶rÃ¼lebilir durumlarÄ±, exception fÄ±rlatmadan Ã¶nce koÅŸullarla kontrol edin ï¿¼. Ã–rneÄŸin, bir koleksiyonda eleman yokken iÅŸlem yapmaya kalkÄ±ÅŸmak yerine Ã¶nceden kontrol (if (list.Any()) ...) etmek, veya bir sÃ¶zlÃ¼kte anahtar yokken TryGetValue kullanmak, exception atmaktan daha verimlidir. Bu, performansÄ± artÄ±rÄ±r ve gereksiz stack trace Ã¼retimini Ã¶nler.
	â€¢	AnlamlÄ± Mesajlar ve Logging: Exception fÄ±rlatÄ±rken mÃ¼mkÃ¼nse aÃ§Ä±klayÄ±Ä±cÄ± mesajlar saÄŸlayÄ±n (Exception.Message). Ã–zellikle kendi Ã¶zel exception sÄ±nÄ±fÄ±nÄ±zÄ± tanÄ±mlÄ±yorsanÄ±z, o hatanÄ±n baÄŸlamÄ±nÄ± anlatan bir mesaj vermek hata ayÄ±klamayÄ± kolaylaÅŸtÄ±rÄ±r. AyrÄ±ca yakalanan hatalarÄ± yutmak yerine uygun bir logging mekanizmasÄ± ile kaydedin. Bu sayede sorunlar gÃ¶zden kaÃ§mamÄ±ÅŸ olur.
	â€¢	Ã–zel Exception TÃ¼rleri: Kendi uygulama mantÄ±ÄŸÄ±nÄ±za Ã¶zgÃ¼ hata durumlarÄ± iÃ§in gerekiyorsa Ã¶zel exception sÄ±nÄ±flarÄ± tanÄ±mlayÄ±n. Ancak mevcut bir .NET exception tÃ¼rÃ¼ amacÄ±nÄ±za hizmet ediyorsa (Ã¶r. argÃ¼man hatasÄ± iÃ§in ArgumentException, yetkisiz eriÅŸim iÃ§in UnauthorizedAccessException gibi) yeniden icat etmeyin ï¿¼. Ã–zel exception sÄ±nÄ±fÄ± oluÅŸturmanÄ±z gerekirse, Exception sÄ±nÄ±fÄ±ndan tÃ¼retin ve ismini ...Exception ile bitirin (Ã¶rn. OrderNotFoundException) ï¿¼. Bu sÄ±nÄ±flara genellikle standart Ã¼Ã§ kurucu (parametresiz, mesajlÄ±, InnerExceptionâ€™lÄ±) eklenir.
	â€¢	Exception Yeniden FÄ±rlatma: Bir catch bloÄŸu iÃ§inde istisnayÄ± iÅŸledikten sonra yukarÄ±ya fÄ±rlatmanÄ±z gerekiyorsa, orijinal stack trace bilgisini koruyarak fÄ±rlatÄ±n. Bunun iÃ§in yakalanan exceptionâ€™Ä± doÄŸrudan throw; ifadesiyle atÄ±n ï¿¼. throw ex; gibi kullanÄ±mlar mevcut stack bilgisini sÄ±fÄ±rlar, hata takibini zorlaÅŸtÄ±rÄ±r. Alternatif olarak, exceptionâ€™Ä± baÅŸka bir exceptionâ€™Ä±n InnerExceptionâ€™Ä± olarak sarmalayabilirsiniz; ancak bu durumda bile orijinal mesaj ve stack bilgisinin korunmasÄ±na Ã¶zen gÃ¶sterin.

6. Asenkron Programlama (Async/Await KullanÄ±mÄ±)
	â€¢	Async Metot Ä°simlendirme: Asenkron metotlar, gerÃ§ekleÅŸtirdikleri iÅŸin sonuna Async takÄ±sÄ± almalÄ±dÄ±r (Ã¶r. GetDataAsync, SaveAsync). Bu .NET konvansiyonu, metodu Ã§aÄŸÄ±ranlara o metodun await edilmesi gereken bir async operasyon olduÄŸunu belirtir ï¿¼. AyrÄ±ca, async anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlanan her metodun iÃ§erisinde en az bir await Ã§aÄŸrÄ±sÄ± bulunmasÄ±na dikkat edin; eÄŸer yoksa derleyici uyarÄ± verecektir.
	â€¢	async void Kullanmaktan KaÃ§Ä±nma: Geri dÃ¶nÃ¼ÅŸ deÄŸeri Task veya Task<T> olan asenkron metotlar tercih edilmelidir. async void sadece olay iÅŸleyiciler (event handlerâ€™lar) gibi Ã§aÄŸrÄ±cÄ± tarafÄ±ndan beklenmeyen durumlar iÃ§in kullanÄ±lmalÄ±dÄ±r ï¿¼ ï¿¼. async void metotlarÄ±ndan fÄ±rlayan hatalar Ã§aÄŸÄ±ran kod tarafÄ±ndan yakalanamaz ve uygulamanÄ±n beklenmedik ÅŸekilde sonlanmasÄ±na yol aÃ§abilir ï¿¼ ï¿¼. Bu nedenle, arayÃ¼z implementasyonlarÄ± veya geri dÃ¶nÃ¼ÅŸ deÄŸeri olmayan asenkron iÅŸlemler dahi mÃ¼mkÃ¼nse Task dÃ¶ndÃ¼recek ÅŸekilde tasarlanmalÄ±dÄ±r.
	â€¢	Tamamen Asenkron Olma (â€œasync all the wayâ€): Asenkron bir yÃ¶ntemi Ã§aÄŸÄ±ran kodun kendisi de mÃ¼mkÃ¼nse asenkron olmalÄ±dÄ±r. Senkron ve asenkron kodu karÄ±ÅŸtÄ±rmak potansiyel deadlock problemlerine yol aÃ§abilir ï¿¼. Ã–zellikle, bir async metodu senkron ÅŸekilde bekletmek (Task.Wait() veya Task.Result kullanmak) Ã¶nerilmez ï¿¼. Bu durum, UI uygulamalarÄ±nda ve ASP.NET senaryolarÄ±nda deadlockâ€™a neden olabilecek yaygÄ±n bir hatadÄ±r. Bunun yerine, Ã§aÄŸrÄ± zincirini baÅŸtan sona await kullanarak asenkron tutmak en iyi uygulamadÄ±r.
	â€¢	KullanÄ±cÄ± ArayÃ¼zÃ¼ ve I/O Ä°ÅŸlemleri: Uzun sÃ¼ren veya I/O bekleten iÅŸlemleri (dosya, veritabanÄ±, web servisi Ã§aÄŸrÄ±larÄ± gibi) async/await patternâ€™i ile gerÃ§ekleÅŸtirin. BÃ¶ylece UI thread bloklanmamÄ±ÅŸ olur ve uygulama yanÄ±t vermeye devam eder. Ã–rneÄŸin, bir dosyayÄ± okurken ReadAsync metodu kullanÄ±p tamamlanmasÄ±nÄ± await etmek, UIâ€™nin donmasÄ±nÄ± engeller.
	â€¢	Ä°ptal ve Zaman AÅŸÄ±mÄ±: Asenkron metotlar uygun olduÄŸunda CancellationToken parametresi alarak iptal edilebilir olmalÄ±dÄ±r. Uzun sÃ¼ren iÅŸlemlerde kullanÄ±cÄ± iptali veya zaman aÅŸÄ±mÄ± gerektiÄŸinde bu token kontrol edilmeli veya ThrowIfCancellationRequested() Ã§aÄŸrÄ±larÄ± yapÄ±lmalÄ±dÄ±r. Bu, uygulamanÄ±n gereksiz iÅŸlemleri devam ettirmeden hÄ±zlÄ±ca iptal olabilmesini saÄŸlar.
	â€¢	KÃ¼tÃ¼phane KodlarÄ±nda Context Yakalamama: KÃ¼tÃ¼phane/altyapÄ± kodu yazarken ConfigureAwait(false) kullanÄ±mÄ± performans ve deadlock riskini yÃ¶netmek aÃ§Ä±sÄ±ndan Ã¶nemlidir ï¿¼. ConfigureAwait(false), await sonrasÄ±nda orijinal synchronization contextâ€™e dÃ¶nmemeyi saÄŸlayarak Ã¶zellikle UI olmayan ortamlarda (Ã¶r. sunucu tarafÄ± kodda) gereksiz context switchâ€™lerini Ã¶nler. Ancak UI uygulamalarÄ±nda (WPF/WinForms/Xamarin) UI gÃ¼ncelleyecek kodunuz varsa ConfigureAwait(true) (veya default davranÄ±ÅŸ) gerekebileceÄŸini unutmayÄ±n.

7. Dependency Injection (BaÄŸÄ±mlÄ±lÄ±klarÄ±n YÃ¶netimi)
	â€¢	GevÅŸek BaÄŸlÄ±lÄ±k (Loose Coupling): SÄ±nÄ±flar arasÄ± baÄŸÄ±mlÄ±lÄ±klarÄ± en aza indirmek iÃ§in Dependency Injection (DI) desenini kullanÄ±n. Bir sÄ±nÄ±f ihtiyaÃ§ duyduÄŸu baÅŸka bir sÄ±nÄ±fÄ± doÄŸrudan kendi iÃ§inde new anahtar sÃ¶zcÃ¼ÄŸÃ¼ ile oluÅŸturmamalÄ±; bunun yerine gereken nesne dÄ±ÅŸarÄ±dan yapÄ±cÄ± metod (constructor) aracÄ±lÄ±ÄŸÄ±yla saÄŸlanmalÄ±dÄ±r ï¿¼. Ã–rneÄŸin, bir iÅŸ sÄ±nÄ±fÄ± iÃ§inde veri eriÅŸim iÃ§in new Repository() yapmak yerine, bir arayÃ¼z IRepository Ã¼zerinden baÄŸÄ±mlÄ±lÄ±ÄŸÄ± alÄ±p, somut sÄ±nÄ±fÄ± DI konteyneri veya Ã¼st seviye kod aracÄ±lÄ±ÄŸÄ±yla enjekte edin. Bu sayede kodunuz belirli bir implementasyona sÄ±kÄ± sÄ±kÄ±ya baÄŸlÄ± olmaz, test edilebilirlik artar.
	â€¢	Soyutlamalara BaÄŸÄ±mlÄ±lÄ±k: DI prensibinin temel amacÄ± olan Dependency Inversion ilkesine uygun olarak, sÄ±nÄ±flarÄ±nÄ±z somut sÄ±nÄ±flardan ziyade arayÃ¼z veya abstract base sÄ±nÄ±flara baÄŸlÄ± olmalÄ±dÄ±r ï¿¼. Ã–rneÄŸin, bir Ã¶deme iÅŸlemi sÄ±nÄ±fÄ± doÄŸrudan PayPalService yerine genel bir IPaymentService arayÃ¼zÃ¼ne baÄŸlÄ± olursa, ileride Ã¶deme saÄŸlayÄ±cÄ±sÄ±nÄ± deÄŸiÅŸtirmek daha az kod deÄŸiÅŸikliÄŸi gerektirecektir. BaÄŸÄ±mlÄ±lÄ±klarÄ± soyutlamak, modÃ¼ler ve deÄŸiÅŸime direnÃ§li bir mimari oluÅŸturur.
	â€¢	BaÄŸÄ±mlÄ±lÄ±k SayÄ±sÄ±nÄ± SÄ±nÄ±rlandÄ±rma: Bir sÄ±nÄ±fÄ±n yapÄ±cÄ± metodu Ã§ok sayÄ±da parametre (baÄŸÄ±mlÄ±lÄ±k) alÄ±yorsa bu, sÄ±nÄ±fÄ±n fazla sorumluluÄŸu olduÄŸunu gÃ¶sterebilir. Ä°deal olarak bir sÄ±nÄ±fÄ±n sorumluluklarÄ± kÄ±sÄ±tlÄ± ve o oranda baÄŸÄ±mlÄ±lÄ±klarÄ± az olmalÄ±dÄ±r. EÄŸer bir sÄ±nÄ±f 4-5â€™ten fazla baÄŸÄ±mlÄ±lÄ±k alÄ±yorsa, Single Responsibility prensibini ihlal ediyor olabilir; bazÄ± iÅŸlevlerini baÅŸka sÄ±nÄ±flara ayÄ±rarak yeniden dÃ¼zenlemeyi dÃ¼ÅŸÃ¼nÃ¼n ï¿¼.
	â€¢	YaÅŸam DÃ¶ngÃ¼sÃ¼ ve Scope: DI kullanÄ±rken nesnelerin yaÅŸam dÃ¶ngÃ¼lerini doÄŸru yÃ¶netmeye Ã¶zen gÃ¶sterin. Ã–rneÄŸin, uygulama genelinde tek bir Ã¶rnek olmasÄ± gereken hizmetler iÃ§in Singleton Ã¶mrÃ¼ kullanÄ±n (ancak global static deÄŸiÅŸken yerine DI container ile yÃ¶netilen singleton tercih edin) ï¿¼. Her istek veya iÅŸlem bazÄ±nda olmasÄ± gerekenler iÃ§in Scoped Ã¶mÃ¼r (Ã¶zellikle web uygulamalarÄ±nda), her ihtiyaÃ§ duyulduÄŸunda yenilenecekler iÃ§in Transient Ã¶mÃ¼r uygun olabilir. Static sÄ±nÄ±flar veya global durum (global state) oluÅŸturmak yerine DI ile yÃ¶netilen tekil nesneler kullanmak, test edilebilirlik ve bellek yÃ¶netimi aÃ§Ä±sÄ±ndan daha iyidir ï¿¼.
	â€¢	Service/Factory KullanÄ±mÄ±: BaÄŸÄ±mlÄ±lÄ±klarÄ± enjekte ederken, gerekirse fabrikalar veya provider desenlerini kullanÄ±n. Ã–rneÄŸin, belli bir anda hangi somut sÄ±nÄ±fÄ±n kullanÄ±lacaÄŸÄ± run-timeâ€™da belirlenecekse, bu kararÄ± veren bir factory sÄ±nÄ±fÄ±nÄ± DI ile enjekte edebilirsiniz. Bu sayede istemci sÄ±nÄ±f her senaryoda doÄŸru implementasyonu dolaylÄ± olarak alÄ±r ve kendi iÃ§inde karar vermek zorunda kalmaz.
	â€¢	DI Container AraÃ§larÄ±: .NET Core ile gelen yerleÅŸik DI Containerâ€™Ä± veya Autofac, Ninject, Unity gibi kÃ¼tÃ¼phaneleri kullanarak baÄŸÄ±mlÄ±lÄ±klarÄ± konfigure edin. Bu araÃ§lar, arayÃ¼z-sÄ±nÄ±f eÅŸleÅŸtirmelerini merkezi olarak tanÄ±mlamanÄ±za ve nesne grafiklerinin otomatik oluÅŸturulmasÄ±na olanak tanÄ±r. Kendi container mekanizmanÄ±zÄ± yazmaktansa gÃ¼venilir bir kÃ¼tÃ¼phane kullanmak hem standartlara uyumu artÄ±rÄ±r hem de yaÅŸam dÃ¶ngÃ¼sÃ¼ yÃ¶netimi gibi konularda hazÄ±r Ã§Ã¶zÃ¼mler sunar.

8. LINQ KullanÄ±mÄ± ve Koleksiyon Ä°ÅŸlemleri
	â€¢	Okunabilirlik iÃ§in LINQ: LINQ, koleksiyonlar Ã¼zerinde filtreleme, sÄ±ralama, dÃ¶nÃ¼ÅŸtÃ¼rme gibi iÅŸlemleri yazÄ±lÄ±mÄ±zÄ± daha deklaratif ve temiz hale getirir. Kod tekrarÄ±nÄ± azaltmak ve amaca yÃ¶nelik net sorgular yazmak iÃ§in LINQ ifadelerini kullanÄ±n. Ã–rneÄŸin, klasik iÃ§ iÃ§e dÃ¶ngÃ¼ler yerine students.Where(s => s.Age > 18).Select(s => s.Name) ÅŸeklindeki bir ifade ne yaptÄ±ÄŸÄ±nÄ± tek bakÄ±ÅŸta anlatÄ±r. Ancak LINQ kullanÄ±rken kodunuzun okunaklÄ±lÄ±ÄŸÄ±nÄ± her zaman Ã¶n planda tutun; Ã§ok karmaÅŸÄ±k veya iÃ§ iÃ§e LINQ ifadeleri yerine gerekirse birden fazla ara deÄŸiÅŸkenle adÄ±m adÄ±m sorgu yazmaktan Ã§ekinmeyin ï¿¼.
	â€¢	Deferred Execution (ErtelenmiÅŸ Ã‡alÄ±ÅŸma): LINQ sorgularÄ±nÄ±n Ã§oÄŸu, sonuÃ§larÄ± talep edilene (iterate edilene) kadar Ã§alÄ±ÅŸtÄ±rÄ±lmaz. Bu Ã¶zelliÄŸin farkÄ±nda olun ve bunu avantaja Ã§evirin. Ã–rneÄŸin, bir sorgunun sonucunu birden fazla kez kullanacaksanÄ±z, deferred execution her Ã§aÄŸrÄ±da veriyi tekrar Ã§ekebilir. Bu durumda, sorgu sonucunu bir listede materyalize etmek iÃ§in ToList() veya ToArray() Ã§aÄŸÄ±rarak bir kerede veriyi Ã§ekmek daha verimli olacaktÄ±r ï¿¼. Aksi halde aynÄ± sorguyu farklÄ± yerlerde tekrar kullanmak, her seferinde baÅŸtan Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±na yol aÃ§abilir.
	â€¢	Yinelenen Koleksiyon GeÃ§iÅŸlerinden KaÃ§Ä±nma: Bir koleksiyonu birden fazla kez dolaÅŸmak (enumeration) performansÄ± olumsuz etkileyebilir. Ã–zellikle LINQ sorgularÄ± ertelenmiÅŸ Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in, aynÄ± IEnumerable Ã¼zerinde birden Ã§ok dÃ¶ngÃ¼ kurmak sorgunun tekraren Ã§alÄ±ÅŸmasÄ±na sebep olur ï¿¼. Bu nedenle, Ã¶rneÄŸin bir koleksiyonda hem filtreleme hem de baÅŸka bir iÅŸlem yapacaksanÄ±z, bunu tek bir LINQ zincirinde birleÅŸtirin veya sonucu bir deÄŸiÅŸkende saklayÄ±n.
	â€¢	Verimli LINQ OperasyonlarÄ±: Sorgularda bazÄ± kÃ¼Ã§Ã¼k optimizasyonlar bÃ¼yÃ¼k etki yapabilir. Ã–rneÄŸin, bir koleksiyonda herhangi bir eleman olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in Any() kullanmak, Count() > 0 kontrolÃ¼nden daha verimlidir (Ã§oÄŸu LINQ saÄŸlayÄ±cÄ±sÄ± iÃ§in Count() tÃ¼m koleksiyonu gezebilir) ï¿¼. Benzer ÅŸekilde, bir listede koÅŸulu saÄŸlayan ilk elemanÄ± bulmak iÃ§in FirstOrDefault() veya Find() kullanÄ±n; Where ile filtreleyip ardÄ±ndan First() Ã§aÄŸÄ±rmak gereksiz yere tÃ¼m koleksiyonu dolaÅŸabilir. LINQ kullanÄ±mÄ±nda her zaman niyetinizi en iyi ifade eden ve en az iÅŸi yapan metodu tercih edin.
	â€¢	DÃ¶ngÃ¼ler ve LINQ Dengesi: LINQ, ifade bazlÄ± temiz bir sÃ¶zdizimi sunsa da, her durumda en optimum yÃ¶ntem olmayabilir. Ã‡ok basit iÅŸlemler iÃ§in klasik for veya foreach dÃ¶ngÃ¼leri LINQâ€™den daha hÄ±zlÄ± olabilir ï¿¼. Ã–zellikle sÄ±k Ã§aÄŸrÄ±lan ve performans kritik kod bÃ¶lgelerinde LINQ sorgularÄ±nÄ±zÄ±n maliyetini analiz edin. Gerekiyorsa, LINQâ€™yi terk etmeden basit optimizasyonlar yapÄ±n (Ã¶r. sorguyu Ã¶nceden bir listeye almak, aÄŸÄ±r hesaplamalarÄ± sorgu dÄ±ÅŸÄ±nda yapmak gibi ï¿¼). UnutmayÄ±n, okunabilirlik ve performans arasÄ±nda bir denge kurulmalÄ±dÄ±r; bu dengeyi saÄŸlamak iÃ§in gerekirse LINQ ifadelerini daha basit parÃ§alara bÃ¶lmekten Ã§ekinmeyin.
	â€¢	Koleksiyon Ä°ÅŸlemlerinde Dikkat: BÃ¼yÃ¼k koleksiyonlarla Ã§alÄ±ÅŸÄ±rken, her adÄ±mda yeni koleksiyonlar oluÅŸturan LINQ zincirleri bellek yÃ¶netimi aÃ§Ä±sÄ±ndan maliyetli olabilir. Ã–rneÄŸin, 1 milyon elemanlÄ± bir listede ardÄ±ÅŸÄ±k Where, Select, OrderBy Ã§aÄŸrÄ±larÄ± yapmak yerine, mÃ¼mkÃ¼nse tek bir sorguda birleÅŸtirmek veya Ã¶zel bir iterator yazmak dÃ¼ÅŸÃ¼nÃ¼lebilir. AyrÄ±ca, LINQ sorgularÄ± iÃ§inde dÄ±ÅŸarÄ±daki deÄŸiÅŸkenleri kullanÄ±rken bu deÄŸiÅŸkenlerin deÄŸiÅŸmezliÄŸine dikkat edin (closureâ€™lar). LINQ to Objects ile LINQ to SQL/Entities arasÄ±nda farklar olduÄŸunu; bazÄ± C# fonksiyonlarÄ±nÄ±n (Math, String operasyonlarÄ± vs.) veritabanÄ±na tercÃ¼me edilemeyeceÄŸini ve bunlarÄ±n sorguyu Ã§alÄ±ÅŸtÄ±rÄ±rken hataya yol aÃ§abileceÄŸini unutmayÄ±n. Bu gibi durumlarda, veritabanÄ±ndan sadece gereken ham veriyi Ã§ekip son iÅŸlemleri bellek Ã¼zerinde yapmak uygun olabilir.

9. Performans ve Verimlilik Ä°Ã§in En Ä°yi Uygulamalar
	â€¢	Algoritma ve Big-O: Kod yazarken sadece Ã§alÄ±ÅŸmasÄ±nÄ± deÄŸil, verimli Ã§alÄ±ÅŸmasÄ±nÄ± da hedefleyin. KullandÄ±ÄŸÄ±nÄ±z algoritmalarÄ±n zaman ve bellek karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± (Big-O notasyonu) gÃ¶z Ã¶nÃ¼nde bulundurun. Ã–rneÄŸin, sÄ±ralÄ± arama O(n) iken ikili arama O(log n) kompleksiteye sahiptir; bÃ¼yÃ¼k verisetlerinde uygun algoritmayÄ± seÃ§mek kritik Ã¶nemdedir. AynÄ± ÅŸekilde, iÃ§ iÃ§e dÃ¶ngÃ¼ler O(n^2) davranÄ±ÅŸ sergileyebilir ve bÃ¼yÃ¼k n deÄŸerlerinde performans sorunu yaratabilir. Bu nedenle, koleksiyonlar Ã¼zerinde iÅŸlem yaparken LINQ kullanÄ±yor olsanÄ±z bile altÄ±nda yatan iÅŸin karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± anlayÄ±n ve gerekirse daha uygun veri yapÄ±larÄ± veya algoritmalar kullanÄ±n.
	â€¢	Gereksiz Nesne OluÅŸturmama: .NETâ€™in Ã§Ã¶p toplayÄ±cÄ±sÄ± (GC) oldukÃ§a optimize olsa da, gereksiz nesne oluÅŸturup yok etmelerden kaÃ§Ä±nmak performansÄ± artÄ±rÄ±r. Ã–zellikle sÄ±k tekrarlanan dÃ¶ngÃ¼lerde her iterasyonda yeni bir nesne (Ã¶r. String, List, vb.) yaratmak yerine, mÃ¼mkÃ¼nse aynÄ± nesnenin Ã¶rneÄŸini yeniden kullanÄ±n veya ArrayPool gibi yapÄ±larla nesneleri havuzlayÄ±n. Struct (deÄŸer tipleri) referans tiplerine gÃ¶re yÄ±ÄŸÄ±n Ã¼zerinde tahsis edildiÄŸi iÃ§in kÃ¼Ã§Ã¼k ve hafif yapÄ±lar iÃ§in struct kullanÄ±mÄ± GC basÄ±ncÄ±nÄ± azaltabilir; ancak yapÄ±nÄ±z bÃ¼yÃ¼kse veya Ã§ok kopyalanacaksa class kullanmak daha iyi olabilir â€“ bu dengeyi tasarÄ±mda dÃ¼ÅŸÃ¼nÃ¼n.
	â€¢	Boxing/Unboxingâ€™ten KaÃ§Ä±nma: DeÄŸer tiplerinin (int, bool, struct vb.) object tipine kutulanmasÄ± (boxing) ve tekrar deÄŸer tipine aÃ§Ä±lmasÄ± (unboxing) ciddi performans maliyeti doÄŸurur. MÃ¼mkÃ¼n mertebe, deÄŸeri kutulanmÄ±ÅŸ olarak tutan eski tip koleksiyonlar yerine generic koleksiyonlar kullanÄ±n (Ã¶rn. ArrayList yerine List<int> kullanmak) ï¿¼. Boxing, arka planda yeni bir nesne yaratÄ±lmasÄ±nÄ± gerektirdiÄŸinden, Ã§ok sÄ±k boxing/unboxing yapÄ±lan senaryolarda 20 kata kadar yavaÅŸlama yaÅŸanabilir ï¿¼.
	â€¢	String Ä°ÅŸlemleri: C#â€™ta String nesneleri deÄŸiÅŸmez (immutable) olduÄŸu iÃ§in, string birleÅŸtirme (str1 + str2 + str3 ÅŸeklinde) arka planda yeni nesneler yaratÄ±r ve maliyetli hale gelebilir. Ã–zellikle dÃ¶ngÃ¼ iÃ§inde yoÄŸun string birleÅŸtirmesi yapÄ±lÄ±yorsa, StringBuilder kullanmak Ã§ok daha verimlidir ï¿¼. StringBuilder, iÃ§ yapÄ±sÄ±nda deÄŸiÅŸebilir bir buffer kullandÄ±ÄŸÄ±ndan, yÃ¼zlerce birleÅŸtirme iÅŸlemini daha az bellek tahsisiyle halleder. AynÄ± ÅŸekilde, formatlama iÃ§in String.Format yerine string interpolation ($â€{}â€) kullanÄ±mÄ± da derleyici tarafÄ±ndan optimize edilir ve daha okunaklÄ±dÄ±r.
	â€¢	Bellek YÃ¶netimi ve Finalizerâ€™lar: C#â€™ta bellek yÃ¶netimi otomatik olsa da, kaynak kullanÄ±mÄ± konusunda dikkatli olmak gerekir. Ã–zellikle IDisposable nesneler (Stream, SqlConnection vb.) iÅŸiniz biter bitmez Dispose() edilmelidir (tercihen using ile). Finalizer (destructor) tanÄ±mlarken de dikkatli olun: BoÅŸ finalizer tanÄ±mlamayÄ±n ï¿¼, bu gereksiz yere nesneyi Finalize kuyruÄŸuna sokar ve Ã§Ã¶p toplayÄ±cÄ±sÄ±nÄ± meÅŸgul eder. Sadece gerÃ§ek anlamda yÃ¶netilmeyen bir kaynaÄŸÄ± serbest bÄ±rakmanÄ±z gerekiyorsa finalizer yazÄ±n. Aksi halde, C# destructor bÄ±rakmak performansa zarar verebilir Ã§Ã¼nkÃ¼ nesne hemen toplanamaz, finalizer threadâ€™inde ek yÃ¼k oluÅŸur.
	â€¢	Veri YapÄ±sÄ± SeÃ§imi: Probleme uygun veri yapÄ±sÄ±nÄ± kullanmak performansÄ± doÄŸrudan etkiler. SÄ±k arama yapacaksanÄ±z List yerine Dictionary veya HashSet kullanmak O(1) arama saÄŸlar. SÄ±ralÄ± tutmak gerekiyorsa List ve gerekirse Sort veya SortedList/SortedDictionary yapÄ±larÄ± dÃ¼ÅŸÃ¼nÃ¼lebilir. Kuyruk iÅŸlemleri iÃ§in Queue, yÄ±ÄŸÄ±n iÅŸlemleri iÃ§in Stack, Ã§ok iÅŸ parÃ§acÄ±klÄ± ortamlar iÃ§in thread-safe koleksiyonlar (ConcurrentDictionary vb.) kullanmak gereksiz kilitlemeleri Ã¶nler. Yani, her zaman diziler ve listeler yeterli deÄŸildir; koleksiyon seÃ§imini kullanÄ±m senaryosuna gÃ¶re optimize edin.
	â€¢	ParalelleÅŸtirme ve Ã‡ok Ã‡ekirdekli KullanÄ±m: UygulamanÄ±z yoÄŸun CPU iÅŸlemleri yapÄ±yorsa, .NETâ€™in TPL (Task Parallel Library) ve PLINQ Ã¶zelliklerini kullanarak iÅŸleri paralelleÅŸtirmeyi dÃ¼ÅŸÃ¼nÃ¼n. Ã–rneÄŸin, baÄŸÄ±msÄ±z iÅŸlevleri Task.Run ile farklÄ± Ã§ekirdeklerde Ã§alÄ±ÅŸtÄ±rÄ±p Task.WhenAll ile beklemek toplam sÃ¼reyi azaltabilir. Veya bÃ¼yÃ¼k bir koleksiyonu iÅŸlerken AsParallel().ForAll(...) gibi yaklaÅŸÄ±mlar ile Ã§ok Ã§ekirdeÄŸi kullanabilirsiniz. Ancak paralel programlama yaparken thread-safety (iÅŸ parÃ§acÄ±ÄŸÄ± gÃ¼venliÄŸi) ve potansiyel yarÄ±ÅŸ koÅŸullarÄ±na (race condition) karÅŸÄ± uygun senkronizasyon Ã¶nlemlerini almayÄ± unutmayÄ±n.
	â€¢	Performans Ã–lÃ§Ã¼m ve Profiling: TÃ¼m performans Ã¶ngÃ¶rÃ¼leri, gerÃ§ek Ã¶lÃ§Ã¼mlerle desteklenmelidir. Kodu yazarken hangi bÃ¶lÃ¼mÃ¼n yavaÅŸlayabileceÄŸini tahmin etmek her zaman doÄŸru sonuÃ§ vermez. Bu yÃ¼zden profiler araÃ§larÄ± (Visual Studio Diagnostic Tools, dotTrace, PerfView vb.) kullanarak uygulamanÄ±zÄ± test edin, aksaklÄ±k veya darboÄŸaz olan yerleri tespit edin. AyrÄ±ca, kritik kod iÃ§in birim testlerine performans karÅŸÄ±laÅŸtÄ±rmalarÄ± ekleyebilir veya BenchmarkDotNet gibi kÃ¼tÃ¼phanelerle mikro benchmarkâ€™lar yazabilirsiniz. Erken optimizasyon yapmak yerine, Ã¶nce Ã§alÄ±ÅŸÄ±r ve doÄŸru kod yazÄ±p sonra gerÃ§ekten yavaÅŸ olan kÄ±sÄ±mlarÄ± optimize etmek en iyi yaklaÅŸÄ±mdÄ±r.

10. Kod Kalitesinin SÃ¼rdÃ¼rÃ¼lmesi ve Otomatik Analiz
	â€¢	Statik Kod Analizi AraÃ§larÄ±: Belirlenen kod standartlarÄ±na uyumu sÃ¼rekli kÄ±lmak iÃ§in araÃ§lardan faydalanÄ±n. Ã–rneÄŸin, StyleCop Analyzers gibi paketler veya .editorconfig ayarlarÄ± ile projenizde kod stili kurallarÄ±nÄ± (isimlendirme, boÅŸluk, bracing vs.) otomatik olarak denetleyebilirsiniz. Derleme anÄ±nda veya CI (Continuous Integration) sÃ¼recinde bu kurallar ihlal edildiÄŸinde uyarÄ±lar verilecektir. Benzer ÅŸekilde, Roslyn Analyzer kÃ¼tÃ¼phaneleri ile kendi takÄ±m kurallarÄ±nÄ±zÄ± dahi tanÄ±mlayabilirsiniz.
	â€¢	SonarQube ve DiÄŸer Kalite AraÃ§larÄ±: Projenizde SonarQube gibi geliÅŸmiÅŸ statik kod analiz araÃ§larÄ±nÄ± entegre edin. SonarQube, kodunuzda olasÄ± hatalarÄ±, kod kokularÄ±nÄ± (code smell), potansiyel gÃ¼venlik aÃ§Ä±klarÄ±nÄ± ve standart ihlallerini tarayarak raporlar. Bu tÃ¼r araÃ§lar yÃ¼zlerce kural Ã¼zerinden kodu deÄŸerlendirdiÄŸinden, takÄ±m standartlarÄ±nÄ±zÄ±n uygulandÄ±ÄŸÄ±nÄ± doÄŸrulamada yardÄ±mcÄ± olur ï¿¼. Ã–rneÄŸin, SonarQube Ã¼zerinden â€œblok iÃ§erisinde boÅŸluk kullanÄ±mÄ±â€ veya â€œmagic number kullanÄ±mÄ±â€ gibi pek Ã§ok kuralÄ± izleyebilir, zaman iÃ§inde metriklerin (Ã¶r. dÃ¶ngÃ¼sel karmaÅŸÄ±klÄ±k, derinlik) sÄ±nÄ±rlarÄ±nÄ± aÅŸmadÄ±ÄŸÄ±ndan emin olabilirsiniz.
	â€¢	Kod Ä°ncelemeleri ve Pull Request KurallarÄ±: Otomatik araÃ§larÄ±n yanÄ± sÄ±ra, ekip iÃ§inde code review (kod inceleme) sÃ¼reÃ§leri tanÄ±mlayÄ±n. Her yeni kod deÄŸiÅŸikliÄŸi (pull request) en az bir ekip Ã¼yesi tarafÄ±ndan gÃ¶zden geÃ§irilerek standartlara uyum, anlaÅŸÄ±labilirlik ve olasÄ± hatalar aÃ§Ä±sÄ±ndan incelenmelidir ï¿¼. Kod incelemelerinde tutarlÄ± bir checklist kullanarak (Ã¶r. â€œisimlendirmeler doÄŸru mu?â€, â€œhata yakalamalar uygun mu?â€ gibi) kalite standardÄ±nÄ±zÄ± koruyabilirsiniz.
	â€¢	SÃ¼rekli Entegrasyon ve Testler: CI/CD sÃ¼reÃ§lerinde style ve analysis araÃ§larÄ±nÄ± entegre edin. Ã–rneÄŸin, build pipelineâ€™Ä±nÄ±za SonarQube taramasÄ±, StyleCop denetimi veya FXCop analizleri ekleyerek geliÅŸtiricilerin lokalde kaÃ§Ä±rabileceÄŸi sorunlarÄ± yakalayÄ±n. Derleme baÅŸarÄ±sÄ±zlÄ±k kriterlerine Ã¶nemli standart ihlallerini dahil edin ki ekip Ã¼yeleri dÃ¼zeltme yapmadan kodu birleÅŸtiremesin. AyrÄ±ca, yÃ¼ksek kaliteli kod demek test edilebilir kod demektir; birim testlerinin yazÄ±lmasÄ±nÄ± teÅŸvik edin ve bu testlerin geÃ§erliliÄŸini CIâ€™da koÅŸarak hem doÄŸruluk hem de belirli Ã¶lÃ§Ã¼de tasarÄ±m kalitesi (SOLIDâ€™e uygun gevÅŸek baÄŸlÄ±lÄ±k gibi) saÄŸlayÄ±n.
	â€¢	DokÃ¼mantasyon ve EÄŸitim: TakÄ±mdaki tÃ¼m geliÅŸtiricilerin bu standartlarÄ± bilmesi ve Ã¶nemini kavramasÄ± gerekir. Yeni baÅŸlayan ekip Ã¼yelerine kodlama standartlarÄ± dokÃ¼manÄ±nÄ± iletin, mÃ¼mkÃ¼nse Ã¶rneklerle destekleyin. StyleCop uyarÄ±larÄ± veya SonarQube raporlarÄ±nda sÄ±k tekrarlanan ihlaller iÃ§in kÄ±sa bir bilgi paylaÅŸÄ±mÄ± yaparak doÄŸrusunu gÃ¶sterin. DÃ¼zenli aralÄ±klarla standartlarÄ± gÃ¶zden geÃ§irip gerekiyorsa takÄ±m konsensÃ¼sÃ¼yle gÃ¼ncelleyin. Kod standartlarÄ± yaÅŸayan bir dokÃ¼mandÄ±r; teknolojideki yeni geliÅŸmelerle (Ã¶r. yeni C# dil Ã¶zellikleri) veya proje ihtiyaÃ§larÄ±yla evrim geÃ§irebilir.

Kaynaklar: Bu standartlar, Microsoftâ€™un resmi .NET yÃ¶nergeleri ï¿¼ ï¿¼, C# topluluk Ã¶nerileri ve yazÄ±lÄ±m geliÅŸtirmede kabul gÃ¶rmÃ¼ÅŸ prensipler (SOLID, Clean Code) temel alÄ±narak hazÄ±rlanmÄ±ÅŸtÄ±r. StyleCop, SonarQube gibi araÃ§lar hakkÄ±nda daha fazla bilgi iÃ§in Microsoft Docs ve ilgili topluluk dÃ¶kÃ¼manlarÄ±na baÅŸvurabilirsiniz. Bu kurallara uyarak, ekip iÃ§inde tutarlÄ±, bakÄ±mÄ± kolay ve yÃ¼ksek kaliteli C# kodu yazÄ±lmasÄ± hedeflenmektedir.



â€¢	Kod okunabilirliÄŸi: Kod standartlarÄ±, kodun daha kolay okunup anlaÅŸÄ±lmasÄ±nÄ± saÄŸlar. TutarlÄ± bir format, girintileme ve isimlendirme kullanÄ±ldÄ±ÄŸÄ±nda, tÃ¼m geliÅŸtiriciler kodu benzer bir ÅŸekilde yazar. Bu sayede bir geliÅŸtirici, baÅŸka bir ekip Ã¼yesinin yazdÄ±ÄŸÄ± kodu rahatlÄ±kla okuyabilir ve ne yaptÄ±ÄŸÄ±nÄ± hÄ±zlÄ±ca kavrayabilir. â€œKod bir kez yazÄ±lÄ±r ama defalarca okunurâ€ sÃ¶zÃ¼nÃ¼n de iÅŸaret ettiÄŸi gibi, okunaklÄ± kod geliÅŸtirme sÃ¼recinde zaman kazandÄ±rÄ±r ve yanlÄ±ÅŸ anlamalarÄ± Ã¶nler.
	â€¢	Yeni geliÅŸtiricilerin adaptasyonu: Kod standartlarÄ±, ekibe yeni katÄ±lan geliÅŸtiricilerin kod tabanÄ±na hÄ±zlÄ±ca adapte olmasÄ±nÄ± saÄŸlar. Projedeki tÃ¼m kod benzer kurallar ve stil altÄ±nda yazÄ±ldÄ±ÄŸÄ±nda, yeni gelen bir geliÅŸtirici kodun yapÄ±sÄ±nÄ± Ã§Ã¶zmek iÃ§in gereksiz zaman harcamaz. Standartlar sayesinde projeye Ã¶zgÃ¼ alÄ±ÅŸkanlÄ±klar ve konvansiyonlar net olduÄŸundan, yeni Ã¼yeler kendilerini daha gÃ¼vende hisseder ve Ã§ekinmeden katkÄ± sunabilir. SonuÃ§ olarak, yeni ekip Ã¼yeleri kÄ±sa sÃ¼rede Ã¼retken hale gelerek projeye deÄŸer katmaya baÅŸlar.
	â€¢	BakÄ±m ve gÃ¼ncelleme kolaylÄ±ÄŸÄ±: Kod standartlarÄ±, yazÄ±lÄ±mÄ±n bakÄ±mÄ±nÄ± ve gÃ¼ncellenmesini kolaylaÅŸtÄ±rÄ±r. Standartlara uygun olarak yazÄ±lmÄ±ÅŸ kod daha anlaÅŸÄ±lÄ±r ve dÃ¼zenli olduÄŸundan, bir Ã¶zelliÄŸi deÄŸiÅŸtirmek veya bir hatayÄ± dÃ¼zeltmek gerektiÄŸinde geliÅŸtiriciler ilgili kodu hÄ±zlÄ±ca bulabilir. TutarlÄ± yapÄ± sayesinde bir deÄŸiÅŸikliÄŸin diÄŸer bÃ¶lÃ¼mlere etkisini anlamak da kolaylaÅŸÄ±r. Bu da gÃ¼ncelleme yaparken hata riskini azaltÄ±r ve bakÄ±m sÃ¼recini hÄ±zlandÄ±rÄ±r.
	â€¢	Kod tutarlÄ±lÄ±ÄŸÄ±: Kod standartlarÄ±, projede yazÄ±lan tÃ¼m kodun tutarlÄ± olmasÄ±nÄ± saÄŸlar. FarklÄ± geliÅŸtiriciler kod yazsa bile ortak standartlar nedeniyle kod sanki tek bir kiÅŸi tarafÄ±ndan yazÄ±lmÄ±ÅŸ gibi gÃ¶rÃ¼nÃ¼r. Bu tutarlÄ±lÄ±k, proje iÃ§inde bir dosyadan diÄŸerine geÃ§erken geliÅŸtiricilerin yabancÄ±lÄ±k Ã§ekmemesini saÄŸlar. Her modÃ¼lde benzer bir yapÄ± ve adlandÄ±rma ile karÅŸÄ±laÅŸmak, kodun anlaÅŸÄ±lmasÄ±nÄ± ve Ã¼zerinde Ã§alÄ±ÅŸÄ±lmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. AyrÄ±ca tutarlÄ± bir kod tabanÄ±, kod gÃ¶zden geÃ§irme ve hata tespit sÃ¼reÃ§lerini de basitleÅŸtirir.
	â€¢	Ekip iÃ§i iÅŸ birliÄŸi: Kod standartlarÄ±, takÄ±m iÃ§inde daha iyi bir iÅŸ birliÄŸi ortamÄ± oluÅŸturur. TÃ¼m ekip Ã¼yeleri aynÄ± kodlama kurallarÄ±na uyduÄŸunda, adeta â€œaynÄ± dildeâ€ iletiÅŸim kurar gibi kod yazarlar. Bu, ekip iÃ§inde yanlÄ±ÅŸ anlaÅŸÄ±lmalarÄ± en aza indirir ve birlikte Ã§alÄ±ÅŸma sÃ¼reÃ§lerini hÄ±zlandÄ±rÄ±r. Kod incelemeleri (code review) daha verimli hale gelir; Ã§Ã¼nkÃ¼ tartÄ±ÅŸmalar kodun stili yerine iÅŸlevselliÄŸi Ã¼zerine odaklanabilir. SonuÃ§ olarak, ekip Ã¼yeleri birbirlerinin kodunu rahatlÄ±kla anlayÄ±p Ã¼zerinde ortak Ã§alÄ±ÅŸabilir hale gelir.
	â€¢	Hata ve buglarÄ± azaltma: Standartlar, yaygÄ±n hatalarÄ±n Ã¶nÃ¼ne geÃ§erek yazÄ±lÄ±mda Ã§Ä±kabilecek hata sayÄ±sÄ±nÄ± azaltÄ±r. Kod standartlarÄ± genellikle en iyi uygulamalarÄ± (best practices) iÃ§erdiÄŸinden, geliÅŸtiriciler bu kurallara uyarak potansiyel hatalardan kaÃ§Ä±nÄ±r. Ã–rneÄŸin, tutarlÄ± deÄŸiÅŸken isimlendirmesi veya belirlenmiÅŸ bir hata yÃ¶netimi deseni sayesinde yanlÄ±ÅŸ deÄŸiÅŸken kullanÄ±mÄ± veya gÃ¶zden kaÃ§an istisnalar gibi problemler daha az yaÅŸanÄ±r. AyrÄ±ca anlaÅŸÄ±lÄ±r ve dÃ¼zenli kod, testler ve kod gÃ¶zden geÃ§irmeler sÄ±rasÄ±nda hatalarÄ±n erken fark edilmesini kolaylaÅŸtÄ±rÄ±r. Bu sayede proje genelinde daha az hata ortaya Ã§Ä±kar ve yazÄ±lÄ±m kalitesi artar.
	â€¢	Performans ve verimlilik: Kodlama standartlarÄ±na uymak, yazÄ±lÄ±mÄ±n performansÄ± ve geliÅŸtirme ekibinin verimliliÄŸi Ã¼zerinde olumlu etki yapar. Standartlar, gereksiz tekrarlarÄ± Ã¶nleyip verimli kodlama tekniklerini teÅŸvik ettiÄŸi iÃ§in uygulamanÄ±n daha verimli ÅŸekilde Ã§alÄ±ÅŸmasÄ±na katkÄ± saÄŸlar. Ã–rneÄŸin, herkesin belirli bir algoritma yapÄ±sÄ±na veya bellek kullanÄ±mÄ± kuralÄ±na uymasÄ±, olasÄ± performans sorunlarÄ±nÄ± en baÅŸtan engelleyebilir. Ekip aÃ§Ä±sÄ±ndan bakÄ±ldÄ±ÄŸÄ±nda, standart bir kod yapÄ±sÄ± sayesinde geliÅŸtiriciler kodu daha hÄ±zlÄ± anlayÄ±p yazabilirler. Bu da zaman kazandÄ±rÄ±r ve ekip genelinde Ã¼retkenliÄŸi artÄ±rÄ±r.
	â€¢	Kodun yeniden kullanÄ±labilirliÄŸi: Kod standartlarÄ±, kodun tekrar tekrar kullanÄ±labilen modÃ¼ller ÅŸeklinde yazÄ±lmasÄ±nÄ± teÅŸvik eder. Ä°yi tanÄ±mlanmÄ±ÅŸ standartlar, geliÅŸtiricileri benzer iÅŸlevleri kopyalamak yerine ortak fonksiyonlar veya kÃ¼tÃ¼phaneler oluÅŸturmaya yÃ¶nlendirir. Bu sayede bir kez yazÄ±lan bir kod parÃ§asÄ±, ihtiyaÃ§ duyulan her yerde tekrar kullanÄ±labilir hale gelir. AynÄ± iÅŸleve sahip kodu yeniden yazmaya gerek kalmaz; bÃ¶ylece zamandan ve efordan tasarruf edilir. AyrÄ±ca, yeniden kullanÄ±labilir kod projenin farklÄ± bÃ¶lÃ¼mleri arasÄ±nda tutarlÄ±lÄ±ÄŸÄ± da artÄ±rÄ±r.
	â€¢	Test sÃ¼reÃ§lerini kolaylaÅŸtÄ±rma: Standartlar sayesinde kodun test edilmesi daha kolay ve etkili hale gelir. TutarlÄ± ve Ã¶ngÃ¶rÃ¼lebilir bir kod yapÄ±sÄ± olduÄŸundan, test senaryolarÄ±nÄ± oluÅŸturmak ve uygulamak daha az karmaÅŸÄ±ktÄ±r. Kodlama standartlarÄ± genellikle fonksiyonlarÄ±n tek bir sorumluluÄŸu olmasÄ±nÄ± ve modÃ¼lerliÄŸi teÅŸvik eder; bu da birim testlerinin yazÄ±lmasÄ±nÄ± basitleÅŸtirir Ã§Ã¼nkÃ¼ her bir parÃ§a baÄŸÄ±msÄ±z olarak test edilebilir. AyrÄ±ca, kod net ve anlaÅŸÄ±lÄ±r olduÄŸunda, testler sÄ±rasÄ±nda beklenmedik davranÄ±ÅŸlarla karÅŸÄ±laÅŸma olasÄ±lÄ±ÄŸÄ± da dÃ¼ÅŸer. BÃ¶ylelikle hem manuel testler hem de otomatik testler daha sorunsuz bir ÅŸekilde yÃ¼rÃ¼tÃ¼lebilir.
	â€¢	Uzun vadede sÃ¼rdÃ¼rÃ¼lebilirlik: Kod standartlarÄ±, bir yazÄ±lÄ±m projesinin yÄ±llar boyu sÃ¼rdÃ¼rÃ¼lebilir olmasÄ±na zemin hazÄ±rlar. Ekip Ã¼yeleri deÄŸiÅŸse bile, standartlara gÃ¶re yazÄ±lmÄ±ÅŸ bir kod tabanÄ± yeni gelenler tarafÄ±ndan kolayca anlaÅŸÄ±labilir ve devam ettirilebilir. Teknolojiler veya gereksinimler zaman iÃ§inde deÄŸiÅŸtiÄŸinde, temiz ve dÃ¼zenli kod bu deÄŸiÅŸikliklere uyum saÄŸlamayÄ± kolaylaÅŸtÄ±rÄ±r; proje geliÅŸimini kesintisiz sÃ¼rdÃ¼rebilir. Buna ek olarak, tutarlÄ± bir yaklaÅŸÄ±m teknik borcun (technical debt) birikmesini Ã¶nleyerek gelecekte bÃ¼yÃ¼k Ã§aplÄ± yeniden yazÄ±mlarÄ±n veya kapsamlÄ± dÃ¼zeltmelerin Ã¶nÃ¼ne geÃ§er. Uzun vadede, kod standartlarÄ±na baÄŸlÄ± kalmak hem bakÄ±m maliyetlerini dÃ¼ÅŸÃ¼rÃ¼r hem de yazÄ±lÄ±mÄ±n gÃ¼venilirliÄŸini artÄ±rÄ±r.


Kod standartlarÄ±nÄ±n ekip iÃ§inde neden Ã¶nemli olduÄŸunu aÅŸaÄŸÄ±daki maddeler halinde aÃ§Ä±k1.	Kod OkunabilirliÄŸini ArtÄ±rÄ±r â€“ Standart bir format ile yazÄ±lmÄ±ÅŸ kod, tÃ¼m ekip Ã¼yeleri tarafÄ±ndan kolayca okunabilir ve anlaÅŸÄ±labilir hale gelir.
	2.	Yeni GeliÅŸtiricilerin Adaptasyonunu KolaylaÅŸtÄ±rÄ±r â€“ Ekibe yeni katÄ±lan geliÅŸtiriciler, belirlenmiÅŸ standartlarÄ± takip ederek projeye daha hÄ±zlÄ± uyum saÄŸlar.
	3.	Kodun BakÄ±mÄ±nÄ± ve GÃ¼ncellenmesini KolaylaÅŸtÄ±rÄ±r â€“ Standart bir yapÄ±ya sahip kod, ilerleyen zamanlarda hata dÃ¼zeltme ve yeni Ã¶zellik ekleme sÃ¼reÃ§lerini hÄ±zlandÄ±rÄ±r.
	4.	Kod TutarlÄ±lÄ±ÄŸÄ±nÄ± SaÄŸlar â€“ AynÄ± proje iÃ§inde farklÄ± yazÄ±lÄ±mcÄ±larÄ±n aynÄ± kurallara gÃ¶re yazÄ±lÄ±m geliÅŸtirmesi, kodda tutarlÄ±lÄ±k saÄŸlar ve kaosu Ã¶nler.
	5.	Ekip Ä°Ã§i Ä°ÅŸ BirliÄŸini GÃ¼Ã§lendirir â€“ Ortak standartlar sayesinde ekip iÃ§i kod incelemeleri (code review) daha verimli olur ve herkes aynÄ± formatÄ± anlar.
	6.	Hata ve BuglarÄ± AzaltÄ±r â€“ Belirli kurallar ve standartlar, kÃ¶tÃ¼ kod yazÄ±mÄ±nÄ± Ã¶nleyerek hata olasÄ±lÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼rÃ¼r.
	7.	PerformansÄ± ve VerimliliÄŸi ArtÄ±rÄ±r â€“ Temiz ve dÃ¼zenli kod, geliÅŸtirme sÃ¼recini hÄ±zlandÄ±rÄ±r ve gereksiz tekrarlarÄ± Ã¶nleyerek ekip verimliliÄŸini artÄ±rÄ±r.
	8.	Kodun Yeniden KullanÄ±labilirliÄŸini ArtÄ±rÄ±r â€“ Standartlara uygun yazÄ±lmÄ±ÅŸ kod parÃ§alarÄ± baÅŸka projelerde veya modÃ¼llerde kolayca tekrar kullanÄ±labilir.
	9.	Test SÃ¼reÃ§lerini KolaylaÅŸtÄ±rÄ±r â€“ DÃ¼zenli ve belirli kurallara gÃ¶re yazÄ±lmÄ±ÅŸ kod, test edilmesi ve otomatik testler ile entegre edilmesi daha kolay hale gelir.
	10.	Kodun Uzun Vadede SÃ¼rdÃ¼rÃ¼lebilir OlmasÄ±nÄ± SaÄŸlar â€“ Standartlara uygun kod, zamanla deÄŸiÅŸen ekip Ã¼yeleri ve teknoloji gereksinimleri karÅŸÄ±sÄ±nda daha dayanÄ±klÄ± olur.

Bu noktalar, ekip iÃ§indeki yazÄ±lÄ±m geliÅŸtirme sÃ¼recini daha verimli, kaliteli ve sÃ¼rdÃ¼rÃ¼lebilir hale getirmek iÃ§in kod standartlarÄ±nÄ±n ne kadar Ã¶nemli olduÄŸunu vurgular.

protected override void OnResize(EventArgs e)
{
    base.OnResize(e);
    UpdateFormColors();
}

private void UpdateFormColors()
{
    if (this.ContainsFocus || WindowState != FormWindowState.Minimized)
    {
        // Form odaklanmÄ±ÅŸsa veya minimize edilmemiÅŸse
        ApplyActiveColors();
    }
    else
    {
        // Form odaklanmamÄ±ÅŸsa veya minimize edilmiÅŸse
        ApplyInactiveColors();
    }
}

private void ApplyActiveColors()
{
    // Aktifken uygulanan renkler
    using (LinearGradientBrush lgb = new LinearGradientBrush(ClientRectangle, Color.DeepSkyBlue, Color.MidnightBlue, LinearGradientMode.Vertical))
    {
        Graphics g = CreateGraphics();
        g.FillRectangle(lgb, ClientRectangle);
    }
}

private void ApplyInactiveColors()
{
    // Pasifken uygulanan renkler
    using (LinearGradientBrush lgb = new LinearGradientBrush(ClientRectangle, Color.Gray, Color.DarkGray, LinearGradientMode.Vertical))
    {
        Graphics g = CreateGraphics();
        g.FillRectangle(lgb, ClientRectangle);
    }
}



using System;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;

public class CustomButton : Button
{
    private Color hoverBackColor = Color.Gray;
    private Color clickEffectColor = Color.DarkGray;
    private int borderRadius = 0;
    private int borderSize = 2;
    private Color borderColor = Color.Black;
    private int animationDuration = 100;
    private int cornerRadius = 20;

    public CustomButton()
    {
        FlatStyle = FlatStyle.Flat;
        FlatAppearance.BorderSize = borderSize;
        FlatAppearance.BorderColor = borderColor;
    }

    [Category("Appearance"), Description("Arka planÄ±n hover rengi.")]
    public Color HoverBackColor
    {
        get { return hoverBackColor; }
        set { hoverBackColor = value; Invalidate(); }
    }

    [Category("Appearance"), Description("TÄ±klama efektinin rengi.")]
    public Color ClickEffectColor
    {
        get { return clickEffectColor; }
        set { clickEffectColor = value; Invalidate(); }
    }

    [Category("Appearance"), Description("Butonun kenarlÄ±k kalÄ±nlÄ±ÄŸÄ±.")]
    public int BorderSize
    {
        get { return borderSize; }
        set { borderSize = value; FlatAppearance.BorderSize = borderSize; Invalidate(); }
    }

    [Category("Appearance"), Description("Butonun kenarlÄ±k rengi.")]
    public Color BorderColor
    {
        get { return borderColor; }
        set { borderColor = value; FlatAppearance.BorderColor = borderColor; Invalidate(); }
    }

    [Category("Behavior"), Description("Animasyon sÃ¼resi (milisaniye).")]
    public int AnimationDuration
    {
        get { return animationDuration; }
        set { animationDuration = value; Invalidate(); }
    }

    [Category("Appearance"), Description("Buton kÃ¶ÅŸelerinin yuvarlaklÄ±k derecesi.")]
    public int CornerRadius
    {
        get { return cornerRadius; }
        set { cornerRadius = value; Invalidate(); }
    }

    [Category("Appearance"), Description("Butonun yuvarlak olup olmamasÄ±.")]
    public bool IsCircular
    {
        get { return borderRadius > Height / 2; }
        set { borderRadius = value ? Height / 2 : 0; Invalidate(); }
    }

    protected override void OnPaint(PaintEventArgs pevent)
    {
        base.OnPaint(pevent);
        pevent.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
        Rectangle rectSurface = ClientRectangle;
        Rectangle 
