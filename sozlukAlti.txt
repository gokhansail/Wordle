using System;
using System.Windows.Forms;
using Kitware.VTK;

public class VTKTriangleForm : Form
{
    private RenderWindowControl renderWindowControl;

    public VTKTriangleForm()
    {
        renderWindowControl = new RenderWindowControl
        {
            Dock = DockStyle.Fill
        };
        this.Controls.Add(renderWindowControl);
        InitializeVTK();
    }

    private void InitializeVTK()
    {
        // 1️⃣ VTK RenderWindow ve Renderer oluştur
        vtkRenderWindow renderWindow = renderWindowControl.RenderWindow;
        vtkRenderer renderer = vtkRenderer.New();
        renderWindow.AddRenderer(renderer);

        // 2️⃣ Üçgenin köşe noktalarını tanımla
        vtkPoints points = vtkPoints.New();
        points.InsertNextPoint(0.0, 0.0, 0.0);  // Nokta 0
        points.InsertNextPoint(1.0, 0.0, 0.0);  // Nokta 1
        points.InsertNextPoint(0.5, 1.0, 0.0);  // Nokta 2

        // 3️⃣ Üçgen oluştur
        vtkTriangle triangle = vtkTriangle.New();
        triangle.GetPointIds().SetId(0, 0);
        triangle.GetPointIds().SetId(1, 1);
        triangle.GetPointIds().SetId(2, 2);

        // 4️⃣ Üçgeni içeren bir hücre (cell) dizisi oluştur
        vtkCellArray triangles = vtkCellArray.New();
        triangles.InsertNextCell(triangle);

        // 5️⃣ PolyData nesnesi oluştur ve noktalar ile üçgeni ekle
        vtkPolyData polyData = vtkPolyData.New();
        polyData.SetPoints(points);
        polyData.SetPolys(triangles);

        // 6️⃣ Mapper ve Actor oluştur
        vtkPolyDataMapper mapper = vtkPolyDataMapper.New();
        mapper.SetInput(polyData);

        vtkActor actor = vtkActor.New();
        actor.SetMapper(mapper);
        actor.GetProperty().SetColor(1.0, 0.0, 0.0); // Kırmızı renk

        // 7️⃣ Renderer'a üçgeni ekleyip sahneyi göster
        renderer.AddActor(actor);
        renderer.SetBackground(0.2, 0.3, 0.4); // Arka plan rengi (mavi tonları)
        renderer.ResetCamera();
    }

    [STAThread]
    static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        Application.Run(new VTKTriangleForm());
    }
}




1. Genel Kodlama Standartları
	•	Girintileme ve Satır Formatı: Tüm girintiler 4 boşluk karakteri ile yapılmalı, sekme (tab) karakteri kullanılmamalıdır ￼. Kod blokları ve alt bloklar tutarlı şekilde hizalanmalı; uzun satırlar okunabilirlik için genelde 100 karakteri geçmemelidir ￼. Her bir kod satırında en fazla bir ifade bulunmalı, bir satırda birden fazla komut veya tanım tanımlanmamalıdır ￼.
	•	Köşeli Parantez (Brace) Stili: C#’ta yaygın olarak Allman stili benimsenmelidir: Açma { ve kapama } süslü parantezleri kendi satırlarında olmalı, mevcut blok girintisi hizasında konumlanmalıdır ￼. Tek satırlık if/else gibi yapılar dahi süslü parantez içinde yazılmalıdır (ileride kod genişleyebileceği için). Ayrıca, if-else/try-catch bloklarında kapanan parantez ile sonraki anahtar kelime (else/catch gibi) aynı satıra yazılmamalıdır.
	•	Boşluk Kullanımı: Anahtar kelimelerden sonra ve virgüllerden sonra bir boşluk bırakın (ör. if ( koşul başlamadan önce boşluk) ￼. Açılan parantezden hemen sonra veya kapanan parantezden önce boşluk koymayın ￼. Tek operand’lı (unary) operatörlerle operand arasında boşluk olmaz (-x, !flag gibi), ancak diğer tüm ikili operatörlerin (+, == vb.) her iki tarafında birer boşluk olmalıdır ￼. Bu kurallar kodun daha temiz ve tutarlı görünmesini sağlar.
	•	Boş Satırlar: Mantıksal blokları ayırmak ve okunabilirliği artırmak için uygun yerde boş satır bırakın. Özellikle, yöntemler ve özellikler (property) arasında en az bir boş satır olmasına özen gösterin ￼. Benzer şekilde, bir sınıf içerisindeki alanlar, metotlar, özellikler gruplanırken aralara boş satırlar konulması kodun bölümlerini görsel olarak ayırarak anlaşılabilirliği artırır.
	•	Yorum Satırları: Anlaşılır yorumlar yazmak iyi bir pratiktir. Kısa açıklamalar için // tek satır yorum kullanın; uzun açıklamalar gerekiyorsa mümkünse birden fazla // satırı şeklinde yazın veya gerektiğinde /* ... */ çok satırlı yorum bloğunu tercih edin ￼. Yorumları mümkünse bir kod satırının sonuna değil, ayrı bir satıra koyun ￼. // yorumlarında imleç ile yorum metni arasında bir boşluk bırakın ve yorum metnine büyük harfle başlayıp nokta (.) ile sonlandırın ￼. Ayrıca, özellikle public API üyeleri için XML yorumları (///) kullanın ki bu açıklamalar IntelliSense’de görünerek dokümantasyon işlevi görsün ￼.
	•	Kod Düzenlemesi: Kod okunabilirliğini artırmak için ifadelerde gerekirse parantez kullanın. Özellikle karmaşık koşullarda her bir koşulu parantez içine almak, önceliklerin anlaşılmasını kolaylaştırır ￼. Uzun ifadeleri birden fazla satıra bölmeniz gerekiyorsa, operatörleri yeni satırın başına alarak hizalı bir görünüm elde edin.

2. İsimlendirme Kuralları
	•	Genel İsimlendirme Stili: .NET ekosisteminde yazılan kodlarda PascalCase ve camelCase standartları kullanılır ￼. Sınıf, metot, property ve public field isimleri PascalCase (HerKelimeninİlkHarfiBüyük) stilinde olmalıdır ￼ ￼. Yerel değişkenler ve metot parametreleri ise camelCase (ilk harf küçük, takip eden kelimeler büyük) stilinde yazılmalıdır ￼.
	•	Sınıf, Yapı ve Arabirim İsimleri: Sınıf ve struct isimleri açık ve anlamlı olmalı, PascalCase kullanılmalıdır ￼. Arabirim (interface) isimleri I harfi ile başlamalıdır (ör. ILogger, IDataService), bu standart arayüzleri hızlı tanımamızı sağlar ￼. Enum tipleri, eğer bir bayrak koleksiyonu (Flags) değilse tekil isimle anılmalı, Flags olarak kullanılacaksa çoğul isim verilmelidir ￼.
	•	Değişken ve Alan İsimleri: Değişken adları, taşıdıkları anlama uygun, açıklayıcı kelimelerden oluşmalıdır ￼. Yerel değişkenler ve parametreler camelCase stilinde yazılırken, özel (private) alan isimleri _ karakteri ile başlamalı ve sonrasında camelCase devam etmelidir (ör. _customerRepository) ￼. Bu, alanları diğer değişkenlerden kolayca ayırt etmeyi sağlar. Statik alanlar için benzer şekilde s_ öneki kullanılabilir (ör. s_cache) ￼.
	•	Sabitler ve Enum Değerleri: const veya readonly olarak tanımlanan sabit değerler de PascalCase ile adlandırılmalıdır ￼. C dilindeki gibi BÜYÜK HARFLE “Screaming Caps” stilinde sabit isimlendirmeden kaçınılmalıdır ￼. Örneğin MaxItems uygun iken MAX_ITEMS ya da MAXITEMS tercih edilmez. Bu sayede sabitler de diğer üyelerle tutarlı bir görünüme sahip olur.
	•	Anlamlı ve Tutarlı İsimler: İsimlendirmede kısaltmalardan kaçının; özellikle ekip içinde anlaşılmayabilecek kısaltmalar kodun bakımını zorlaştırır ￼. Sadece genel kabul görmüş kısaltmalar gerekiyorsa kullanılabilir (ör. Http, XML, UID). Bu tür kısaltmalarda da 2 harfli olanlar büyük harflerle (IO), 3 veya daha fazla harften oluşanlar PascalCase içinde normal kelime gibi (XmlDocument, SqlConnection) yazılır ￼.
	•	İsimlendirmede Yanlış Uygulamalardan Kaçınma: Hungarian notation (değişken adında tür belirtme, ör. strName, iCount gibi) kullanılmamalıdır ￼ – modern IDE ve derleyiciler tür bilgisini zaten sağladığı için bu gereksizdir. İsimlerde birden fazla alt tire (__) kullanmaktan kaçının; iki alt tire kombinasyonları derleyici tarafından özel isimler için kullanılabilir ￼. Ayrıca, çok genel tek harfli değişken adları kullanılmamalı; yalnızca döngü sayaçlarında i, j, k gibi anlamı geleneksel olarak anlaşılan harfler tek harf olarak kabul edilebilir ￼.

3. Kod Düzeni ve Yapısı
	•	Using ve Namespace Düzeni: using yönergeleri dosyanın başında, namespace tanımından önce yer almalıdır. İmkan varsa using ifadelerini alfabetik olarak sıralayın; ayrıca genellikle System ile başlayan using’ler en üstte tutulur ￼. Ardından proje/uygulama kapsamındaki diğer namespace importları gelir.
	•	Namespace Organizasyonu: Namespace isimleri, projeyi yansıtan hiyerarşik bir yapıda ve PascalCase stilde olmalıdır (ör. SirketAdi.ProjeAdi.ModulAdi). İsimler anlamlı ve tanımlayıcı seçilmeli, mümkünse şirket alan adına göre ters şekilde organize edilmelidir (ör. Com.Contoso.eCommerce.OrderService) ￼. Dosya sistemi (klasörler) ile namespace hiyerarşisi paralel tutulursa, doğru dosyada doğru kodu bulmak kolaylaşır.
	•	Dosya Başına Tek Sınıf: Her bir C# kod dosyasında mümkünse yalnızca bir tane public tür tanımlayın (sınıf, arayüz, enum vb.) ￼. Dosya adı, içerdiği ana sınıf veya yapının adıyla birebir aynı olmalıdır (örn. CustomerService.cs içinde public class CustomerService) ￼. Bu kural, dosya bazında sürüm kontrolünü ve kodun bulunmasını kolaylaştırır. (İstisna olarak, bir sınıfın partial parçaları veya o sınıfa ait iç içe tipler aynı dosyada olabilir.) ￼
	•	Sınıf İçi Üye Sıralaması: Bir sınıf içindeki üyelerin tutarlı bir sırayla yerleştirilmesi okunabilirliği artırır. Önerilen bir sıralama: Önce iç içe tanımlı sınıf, enum, delegete ve event’ler; ardından sabit (const) ve statik (static) alanlar; sonra örnek alanlar; özellikler; kurucu (constructor) ve destructor/yıkıcılar; en son da metotlar ￼. Her bir grup içinde de üyeleri erişim belirtecine göre sıralayın (önce public, sonra internal, protected internal, protected ve son olarak private) ￼. Bu düzen, kod okuyucusunun sınıfın yapısını hızlıca kavramasını sağlar.
	•	Proje ve Çözüm Organizasyonu: Büyük projelerde kod, katmanlara veya işlevsel alt modüllere ayrılmalıdır. Örneğin, ayrı bir veri erişim katmanı (Repository veya DAL), ayrı bir iş mantığı katmanı ve ayrı bir UI veya API katmanı projeleri şeklinde organize edilebilir. Her proje kendi sorumluluğuna uygun sınıfları içerirken, ortak kodlar paylaşılan kütüphanelere alınmalıdır. Assembly (derleme) adlarını da amacını belli edecek şekilde seçin ￼. Bu sayede çözüm genelinde tutarlı bir modüler yapı korunur.

4. Metot ve Sınıf Tasarımı (SOLID İlkeleri)
	•	Single Responsibility (Tek Sorumluluk) Prensibi: Her sınıf veya metodun tek bir sorumluluğu olmalıdır. Başka bir deyişle, değişmek için tek bir nedeni olmalıdır ￼. Bir sınıf birden fazla işi yapmaya çalışıyorsa bakım zorlaşır; sınıflarınızı daha küçük parçalara bölüp her birini belirli bir iş için uzmanlaştırın. Örneğin, bir sınıf hem veritabanı işlemlerini hem de iş mantığını yapıyorsa iki ayrı sınıfa ayrılmalıdır.
	•	Open/Closed (Açık/Kapalı) Prensibi: Kodunuz yeni özellikler eklemeye açık, ancak mevcut davranışı değiştirmeye kapalı olmalıdır. Yani var olan sınıfları değiştirmek zorunda kalmaksızın yeni işlevsellik ekleyebilmelisiniz ￼. Bunu sağlamak için sınıflarınızı soyutlayın ve genişletilebilir hale getirin (örn. arabirimler veya abstract sınıflar ile temel davranışı tanımlayıp, yeni sınıflarla genişletme yapın). Mevcut kodu değiştirmek, yeni hatalar riskini artırır; bunun yerine miras alma veya yeni sınıflar oluşturma yoluyla genişleme tercih edilmelidir.
	•	Liskov Substitution (Yerine Geçme) Prensibi: Türetilmiş (subclass) sınıflar, her zaman temel sınıfların yerini alabilecek şekilde davranmalıdır. Teknik ifade ile, eğer S sınıfı T sınıfının bir alt türü ise, programda T tipinin beklendiği her yerde S kullanılabilmeli ve programın doğruluğu bozulmamalıdır ￼. Bu prensip, miras hiyerarşilerinde tutarlılığı sağlar. Alt sınıflar, base sınıfın sözleşmesini ihlal edecek davranışlar eklememelidir. Örneğin, bir alt sınıf base sınıftaki bir metodu etkisiz hale getirmemeli veya anlamsal olarak farklı çalıştırmamalıdır.
	•	Interface Segregation (Arayüz Ayrımı) Prensibi: Kullanılmayan metotları içeren büyük arayüzler tanımlamaktan kaçının. Mümkün olduğunca spesifik ve küçük arayüzler oluşturun; böylece sınıflar gereksiz metotlara bağımlı kalmaz ￼. Prensip, “Hiçbir istemci kullanmadığı bir yönteme bağımlı olmaya zorlanmamalıdır” der. Örneğin, tek bir geniş arayüz yerine, ilgili üyeleri gruplandıran birden fazla dar arayüz tanımlamak, implementasyonların ihtiyacı olmayan üyeleri görmezden gelmesini engeller. Bu yaklaşım, kodunuzun bağımlılıklarını azaltır ve değişiklik durumunda etkiyi en aza indirir.
	•	Dependency Inversion (Bağımlılıkları Ters Çevirme) Prensibi: Yüksek seviye modüller (sınıflar), düşük seviye modüllere direkt bağımlı olmamalıdır; her ikisi de abstractions (soyutlamalar) üzerine bağımlı olmalıdır ￼. Yani, somut sınıflar yerine arabirimler veya abstract sınıflar üzerinden bağımlılık tanımlayın. Bu prensip, bağımlılık enjeksiyonu (DI) deseninin temelini oluşturur. Örneğin, bir sınıf bir veritabanı erişim sınıfını doğrudan çağırmak yerine bir arayüz (örn. IDataRepository) üzerinden çalışırsa, alt katmanları değiştirmek (farklı bir veri kaynağına geçmek gibi) daha az kod değişikliğiyle mümkün olacaktır.

5. Exception Handling (Hata Yönetimi)
	•	Spesifik Hataları Yakalama: Hata yakalama bloklarında mümkün olduğunca belirli exception tiplerini yakalamaya özen gösterin. try/catch kullanırken, önce özel durum sınıflarını (örn. IOException, SqlException) yakalayın, en son genel Exception yakalayacak blok varsa tanımlayın ￼. Bu sayede beklenen hatalar kontrollü şekilde ele alınır. Uygulamanızın toparlanamayacağı bir durum oluştuğunda (örneğin belleğin tükenmesi), bu istisnaları yakalamayıp üst katmana bırakmak daha doğrudur. Genel kural: Yakalayamayacağınız veya anlamlı bir şekilde işleyemeyeceğiniz exception’ları yakalamayın ￼ ￼.
	•	Kaynakların Serbest Bırakılması: Hata olsa da olmasa da sistem kaynaklarının düzgün salındığından emin olun. Bunun için finally bloklarını veya using yapısını kullanın. Örneğin, bir dosya okuma işlemi yaparken dosyayı kapatmak için using (var file = File.Open(...)) { ... } deseni takip edilmelidir ￼. finally bloğu, ister hata atsın ister atmasın, her durumda çalışacağı için kaynak temizliği (dosya kapama, bellek boşaltma vb.) için idealdir.
	•	Exception ile Kontrol Akışı Yapmama: Hataları normal akışın bir parçası olarak kullanmayın. Öngörülebilir durumları, exception fırlatmadan önce koşullarla kontrol edin ￼. Örneğin, bir koleksiyonda eleman yokken işlem yapmaya kalkışmak yerine önceden kontrol (if (list.Any()) ...) etmek, veya bir sözlükte anahtar yokken TryGetValue kullanmak, exception atmaktan daha verimlidir. Bu, performansı artırır ve gereksiz stack trace üretimini önler.
	•	Anlamlı Mesajlar ve Logging: Exception fırlatırken mümkünse açıklayııcı mesajlar sağlayın (Exception.Message). Özellikle kendi özel exception sınıfınızı tanımlıyorsanız, o hatanın bağlamını anlatan bir mesaj vermek hata ayıklamayı kolaylaştırır. Ayrıca yakalanan hataları yutmak yerine uygun bir logging mekanizması ile kaydedin. Bu sayede sorunlar gözden kaçmamış olur.
	•	Özel Exception Türleri: Kendi uygulama mantığınıza özgü hata durumları için gerekiyorsa özel exception sınıfları tanımlayın. Ancak mevcut bir .NET exception türü amacınıza hizmet ediyorsa (ör. argüman hatası için ArgumentException, yetkisiz erişim için UnauthorizedAccessException gibi) yeniden icat etmeyin ￼. Özel exception sınıfı oluşturmanız gerekirse, Exception sınıfından türetin ve ismini ...Exception ile bitirin (örn. OrderNotFoundException) ￼. Bu sınıflara genellikle standart üç kurucu (parametresiz, mesajlı, InnerException’lı) eklenir.
	•	Exception Yeniden Fırlatma: Bir catch bloğu içinde istisnayı işledikten sonra yukarıya fırlatmanız gerekiyorsa, orijinal stack trace bilgisini koruyarak fırlatın. Bunun için yakalanan exception’ı doğrudan throw; ifadesiyle atın ￼. throw ex; gibi kullanımlar mevcut stack bilgisini sıfırlar, hata takibini zorlaştırır. Alternatif olarak, exception’ı başka bir exception’ın InnerException’ı olarak sarmalayabilirsiniz; ancak bu durumda bile orijinal mesaj ve stack bilgisinin korunmasına özen gösterin.

6. Asenkron Programlama (Async/Await Kullanımı)
	•	Async Metot İsimlendirme: Asenkron metotlar, gerçekleştirdikleri işin sonuna Async takısı almalıdır (ör. GetDataAsync, SaveAsync). Bu .NET konvansiyonu, metodu çağıranlara o metodun await edilmesi gereken bir async operasyon olduğunu belirtir ￼. Ayrıca, async anahtar sözcüğüyle tanımlanan her metodun içerisinde en az bir await çağrısı bulunmasına dikkat edin; eğer yoksa derleyici uyarı verecektir.
	•	async void Kullanmaktan Kaçınma: Geri dönüş değeri Task veya Task<T> olan asenkron metotlar tercih edilmelidir. async void sadece olay işleyiciler (event handler’lar) gibi çağrıcı tarafından beklenmeyen durumlar için kullanılmalıdır ￼ ￼. async void metotlarından fırlayan hatalar çağıran kod tarafından yakalanamaz ve uygulamanın beklenmedik şekilde sonlanmasına yol açabilir ￼ ￼. Bu nedenle, arayüz implementasyonları veya geri dönüş değeri olmayan asenkron işlemler dahi mümkünse Task döndürecek şekilde tasarlanmalıdır.
	•	Tamamen Asenkron Olma (“async all the way”): Asenkron bir yöntemi çağıran kodun kendisi de mümkünse asenkron olmalıdır. Senkron ve asenkron kodu karıştırmak potansiyel deadlock problemlerine yol açabilir ￼. Özellikle, bir async metodu senkron şekilde bekletmek (Task.Wait() veya Task.Result kullanmak) önerilmez ￼. Bu durum, UI uygulamalarında ve ASP.NET senaryolarında deadlock’a neden olabilecek yaygın bir hatadır. Bunun yerine, çağrı zincirini baştan sona await kullanarak asenkron tutmak en iyi uygulamadır.
	•	Kullanıcı Arayüzü ve I/O İşlemleri: Uzun süren veya I/O bekleten işlemleri (dosya, veritabanı, web servisi çağrıları gibi) async/await pattern’i ile gerçekleştirin. Böylece UI thread bloklanmamış olur ve uygulama yanıt vermeye devam eder. Örneğin, bir dosyayı okurken ReadAsync metodu kullanıp tamamlanmasını await etmek, UI’nin donmasını engeller.
	•	İptal ve Zaman Aşımı: Asenkron metotlar uygun olduğunda CancellationToken parametresi alarak iptal edilebilir olmalıdır. Uzun süren işlemlerde kullanıcı iptali veya zaman aşımı gerektiğinde bu token kontrol edilmeli veya ThrowIfCancellationRequested() çağrıları yapılmalıdır. Bu, uygulamanın gereksiz işlemleri devam ettirmeden hızlıca iptal olabilmesini sağlar.
	•	Kütüphane Kodlarında Context Yakalamama: Kütüphane/altyapı kodu yazarken ConfigureAwait(false) kullanımı performans ve deadlock riskini yönetmek açısından önemlidir ￼. ConfigureAwait(false), await sonrasında orijinal synchronization context’e dönmemeyi sağlayarak özellikle UI olmayan ortamlarda (ör. sunucu tarafı kodda) gereksiz context switch’lerini önler. Ancak UI uygulamalarında (WPF/WinForms/Xamarin) UI güncelleyecek kodunuz varsa ConfigureAwait(true) (veya default davranış) gerekebileceğini unutmayın.

7. Dependency Injection (Bağımlılıkların Yönetimi)
	•	Gevşek Bağlılık (Loose Coupling): Sınıflar arası bağımlılıkları en aza indirmek için Dependency Injection (DI) desenini kullanın. Bir sınıf ihtiyaç duyduğu başka bir sınıfı doğrudan kendi içinde new anahtar sözcüğü ile oluşturmamalı; bunun yerine gereken nesne dışarıdan yapıcı metod (constructor) aracılığıyla sağlanmalıdır ￼. Örneğin, bir iş sınıfı içinde veri erişim için new Repository() yapmak yerine, bir arayüz IRepository üzerinden bağımlılığı alıp, somut sınıfı DI konteyneri veya üst seviye kod aracılığıyla enjekte edin. Bu sayede kodunuz belirli bir implementasyona sıkı sıkıya bağlı olmaz, test edilebilirlik artar.
	•	Soyutlamalara Bağımlılık: DI prensibinin temel amacı olan Dependency Inversion ilkesine uygun olarak, sınıflarınız somut sınıflardan ziyade arayüz veya abstract base sınıflara bağlı olmalıdır ￼. Örneğin, bir ödeme işlemi sınıfı doğrudan PayPalService yerine genel bir IPaymentService arayüzüne bağlı olursa, ileride ödeme sağlayıcısını değiştirmek daha az kod değişikliği gerektirecektir. Bağımlılıkları soyutlamak, modüler ve değişime dirençli bir mimari oluşturur.
	•	Bağımlılık Sayısını Sınırlandırma: Bir sınıfın yapıcı metodu çok sayıda parametre (bağımlılık) alıyorsa bu, sınıfın fazla sorumluluğu olduğunu gösterebilir. İdeal olarak bir sınıfın sorumlulukları kısıtlı ve o oranda bağımlılıkları az olmalıdır. Eğer bir sınıf 4-5’ten fazla bağımlılık alıyorsa, Single Responsibility prensibini ihlal ediyor olabilir; bazı işlevlerini başka sınıflara ayırarak yeniden düzenlemeyi düşünün ￼.
	•	Yaşam Döngüsü ve Scope: DI kullanırken nesnelerin yaşam döngülerini doğru yönetmeye özen gösterin. Örneğin, uygulama genelinde tek bir örnek olması gereken hizmetler için Singleton ömrü kullanın (ancak global static değişken yerine DI container ile yönetilen singleton tercih edin) ￼. Her istek veya işlem bazında olması gerekenler için Scoped ömür (özellikle web uygulamalarında), her ihtiyaç duyulduğunda yenilenecekler için Transient ömür uygun olabilir. Static sınıflar veya global durum (global state) oluşturmak yerine DI ile yönetilen tekil nesneler kullanmak, test edilebilirlik ve bellek yönetimi açısından daha iyidir ￼.
	•	Service/Factory Kullanımı: Bağımlılıkları enjekte ederken, gerekirse fabrikalar veya provider desenlerini kullanın. Örneğin, belli bir anda hangi somut sınıfın kullanılacağı run-time’da belirlenecekse, bu kararı veren bir factory sınıfını DI ile enjekte edebilirsiniz. Bu sayede istemci sınıf her senaryoda doğru implementasyonu dolaylı olarak alır ve kendi içinde karar vermek zorunda kalmaz.
	•	DI Container Araçları: .NET Core ile gelen yerleşik DI Container’ı veya Autofac, Ninject, Unity gibi kütüphaneleri kullanarak bağımlılıkları konfigure edin. Bu araçlar, arayüz-sınıf eşleştirmelerini merkezi olarak tanımlamanıza ve nesne grafiklerinin otomatik oluşturulmasına olanak tanır. Kendi container mekanizmanızı yazmaktansa güvenilir bir kütüphane kullanmak hem standartlara uyumu artırır hem de yaşam döngüsü yönetimi gibi konularda hazır çözümler sunar.

8. LINQ Kullanımı ve Koleksiyon İşlemleri
	•	Okunabilirlik için LINQ: LINQ, koleksiyonlar üzerinde filtreleme, sıralama, dönüştürme gibi işlemleri yazılımızı daha deklaratif ve temiz hale getirir. Kod tekrarını azaltmak ve amaca yönelik net sorgular yazmak için LINQ ifadelerini kullanın. Örneğin, klasik iç içe döngüler yerine students.Where(s => s.Age > 18).Select(s => s.Name) şeklindeki bir ifade ne yaptığını tek bakışta anlatır. Ancak LINQ kullanırken kodunuzun okunaklılığını her zaman ön planda tutun; çok karmaşık veya iç içe LINQ ifadeleri yerine gerekirse birden fazla ara değişkenle adım adım sorgu yazmaktan çekinmeyin ￼.
	•	Deferred Execution (Ertelenmiş Çalışma): LINQ sorgularının çoğu, sonuçları talep edilene (iterate edilene) kadar çalıştırılmaz. Bu özelliğin farkında olun ve bunu avantaja çevirin. Örneğin, bir sorgunun sonucunu birden fazla kez kullanacaksanız, deferred execution her çağrıda veriyi tekrar çekebilir. Bu durumda, sorgu sonucunu bir listede materyalize etmek için ToList() veya ToArray() çağırarak bir kerede veriyi çekmek daha verimli olacaktır ￼. Aksi halde aynı sorguyu farklı yerlerde tekrar kullanmak, her seferinde baştan çalıştırılmasına yol açabilir.
	•	Yinelenen Koleksiyon Geçişlerinden Kaçınma: Bir koleksiyonu birden fazla kez dolaşmak (enumeration) performansı olumsuz etkileyebilir. Özellikle LINQ sorguları ertelenmiş çalıştığı için, aynı IEnumerable üzerinde birden çok döngü kurmak sorgunun tekraren çalışmasına sebep olur ￼. Bu nedenle, örneğin bir koleksiyonda hem filtreleme hem de başka bir işlem yapacaksanız, bunu tek bir LINQ zincirinde birleştirin veya sonucu bir değişkende saklayın.
	•	Verimli LINQ Operasyonları: Sorgularda bazı küçük optimizasyonlar büyük etki yapabilir. Örneğin, bir koleksiyonda herhangi bir eleman olup olmadığını kontrol etmek için Any() kullanmak, Count() > 0 kontrolünden daha verimlidir (çoğu LINQ sağlayıcısı için Count() tüm koleksiyonu gezebilir) ￼. Benzer şekilde, bir listede koşulu sağlayan ilk elemanı bulmak için FirstOrDefault() veya Find() kullanın; Where ile filtreleyip ardından First() çağırmak gereksiz yere tüm koleksiyonu dolaşabilir. LINQ kullanımında her zaman niyetinizi en iyi ifade eden ve en az işi yapan metodu tercih edin.
	•	Döngüler ve LINQ Dengesi: LINQ, ifade bazlı temiz bir sözdizimi sunsa da, her durumda en optimum yöntem olmayabilir. Çok basit işlemler için klasik for veya foreach döngüleri LINQ’den daha hızlı olabilir ￼. Özellikle sık çağrılan ve performans kritik kod bölgelerinde LINQ sorgularınızın maliyetini analiz edin. Gerekiyorsa, LINQ’yi terk etmeden basit optimizasyonlar yapın (ör. sorguyu önceden bir listeye almak, ağır hesaplamaları sorgu dışında yapmak gibi ￼). Unutmayın, okunabilirlik ve performans arasında bir denge kurulmalıdır; bu dengeyi sağlamak için gerekirse LINQ ifadelerini daha basit parçalara bölmekten çekinmeyin.
	•	Koleksiyon İşlemlerinde Dikkat: Büyük koleksiyonlarla çalışırken, her adımda yeni koleksiyonlar oluşturan LINQ zincirleri bellek yönetimi açısından maliyetli olabilir. Örneğin, 1 milyon elemanlı bir listede ardışık Where, Select, OrderBy çağrıları yapmak yerine, mümkünse tek bir sorguda birleştirmek veya özel bir iterator yazmak düşünülebilir. Ayrıca, LINQ sorguları içinde dışarıdaki değişkenleri kullanırken bu değişkenlerin değişmezliğine dikkat edin (closure’lar). LINQ to Objects ile LINQ to SQL/Entities arasında farklar olduğunu; bazı C# fonksiyonlarının (Math, String operasyonları vs.) veritabanına tercüme edilemeyeceğini ve bunların sorguyu çalıştırırken hataya yol açabileceğini unutmayın. Bu gibi durumlarda, veritabanından sadece gereken ham veriyi çekip son işlemleri bellek üzerinde yapmak uygun olabilir.

9. Performans ve Verimlilik İçin En İyi Uygulamalar
	•	Algoritma ve Big-O: Kod yazarken sadece çalışmasını değil, verimli çalışmasını da hedefleyin. Kullandığınız algoritmaların zaman ve bellek karmaşıklığını (Big-O notasyonu) göz önünde bulundurun. Örneğin, sıralı arama O(n) iken ikili arama O(log n) kompleksiteye sahiptir; büyük verisetlerinde uygun algoritmayı seçmek kritik önemdedir. Aynı şekilde, iç içe döngüler O(n^2) davranış sergileyebilir ve büyük n değerlerinde performans sorunu yaratabilir. Bu nedenle, koleksiyonlar üzerinde işlem yaparken LINQ kullanıyor olsanız bile altında yatan işin karmaşıklığını anlayın ve gerekirse daha uygun veri yapıları veya algoritmalar kullanın.
	•	Gereksiz Nesne Oluşturmama: .NET’in çöp toplayıcısı (GC) oldukça optimize olsa da, gereksiz nesne oluşturup yok etmelerden kaçınmak performansı artırır. Özellikle sık tekrarlanan döngülerde her iterasyonda yeni bir nesne (ör. String, List, vb.) yaratmak yerine, mümkünse aynı nesnenin örneğini yeniden kullanın veya ArrayPool gibi yapılarla nesneleri havuzlayın. Struct (değer tipleri) referans tiplerine göre yığın üzerinde tahsis edildiği için küçük ve hafif yapılar için struct kullanımı GC basıncını azaltabilir; ancak yapınız büyükse veya çok kopyalanacaksa class kullanmak daha iyi olabilir – bu dengeyi tasarımda düşünün.
	•	Boxing/Unboxing’ten Kaçınma: Değer tiplerinin (int, bool, struct vb.) object tipine kutulanması (boxing) ve tekrar değer tipine açılması (unboxing) ciddi performans maliyeti doğurur. Mümkün mertebe, değeri kutulanmış olarak tutan eski tip koleksiyonlar yerine generic koleksiyonlar kullanın (örn. ArrayList yerine List<int> kullanmak) ￼. Boxing, arka planda yeni bir nesne yaratılmasını gerektirdiğinden, çok sık boxing/unboxing yapılan senaryolarda 20 kata kadar yavaşlama yaşanabilir ￼.
	•	String İşlemleri: C#’ta String nesneleri değişmez (immutable) olduğu için, string birleştirme (str1 + str2 + str3 şeklinde) arka planda yeni nesneler yaratır ve maliyetli hale gelebilir. Özellikle döngü içinde yoğun string birleştirmesi yapılıyorsa, StringBuilder kullanmak çok daha verimlidir ￼. StringBuilder, iç yapısında değişebilir bir buffer kullandığından, yüzlerce birleştirme işlemini daha az bellek tahsisiyle halleder. Aynı şekilde, formatlama için String.Format yerine string interpolation ($”{}”) kullanımı da derleyici tarafından optimize edilir ve daha okunaklıdır.
	•	Bellek Yönetimi ve Finalizer’lar: C#’ta bellek yönetimi otomatik olsa da, kaynak kullanımı konusunda dikkatli olmak gerekir. Özellikle IDisposable nesneler (Stream, SqlConnection vb.) işiniz biter bitmez Dispose() edilmelidir (tercihen using ile). Finalizer (destructor) tanımlarken de dikkatli olun: Boş finalizer tanımlamayın ￼, bu gereksiz yere nesneyi Finalize kuyruğuna sokar ve çöp toplayıcısını meşgul eder. Sadece gerçek anlamda yönetilmeyen bir kaynağı serbest bırakmanız gerekiyorsa finalizer yazın. Aksi halde, C# destructor bırakmak performansa zarar verebilir çünkü nesne hemen toplanamaz, finalizer thread’inde ek yük oluşur.
	•	Veri Yapısı Seçimi: Probleme uygun veri yapısını kullanmak performansı doğrudan etkiler. Sık arama yapacaksanız List yerine Dictionary veya HashSet kullanmak O(1) arama sağlar. Sıralı tutmak gerekiyorsa List ve gerekirse Sort veya SortedList/SortedDictionary yapıları düşünülebilir. Kuyruk işlemleri için Queue, yığın işlemleri için Stack, çok iş parçacıklı ortamlar için thread-safe koleksiyonlar (ConcurrentDictionary vb.) kullanmak gereksiz kilitlemeleri önler. Yani, her zaman diziler ve listeler yeterli değildir; koleksiyon seçimini kullanım senaryosuna göre optimize edin.
	•	Paralelleştirme ve Çok Çekirdekli Kullanım: Uygulamanız yoğun CPU işlemleri yapıyorsa, .NET’in TPL (Task Parallel Library) ve PLINQ özelliklerini kullanarak işleri paralelleştirmeyi düşünün. Örneğin, bağımsız işlevleri Task.Run ile farklı çekirdeklerde çalıştırıp Task.WhenAll ile beklemek toplam süreyi azaltabilir. Veya büyük bir koleksiyonu işlerken AsParallel().ForAll(...) gibi yaklaşımlar ile çok çekirdeği kullanabilirsiniz. Ancak paralel programlama yaparken thread-safety (iş parçacığı güvenliği) ve potansiyel yarış koşullarına (race condition) karşı uygun senkronizasyon önlemlerini almayı unutmayın.
	•	Performans Ölçüm ve Profiling: Tüm performans öngörüleri, gerçek ölçümlerle desteklenmelidir. Kodu yazarken hangi bölümün yavaşlayabileceğini tahmin etmek her zaman doğru sonuç vermez. Bu yüzden profiler araçları (Visual Studio Diagnostic Tools, dotTrace, PerfView vb.) kullanarak uygulamanızı test edin, aksaklık veya darboğaz olan yerleri tespit edin. Ayrıca, kritik kod için birim testlerine performans karşılaştırmaları ekleyebilir veya BenchmarkDotNet gibi kütüphanelerle mikro benchmark’lar yazabilirsiniz. Erken optimizasyon yapmak yerine, önce çalışır ve doğru kod yazıp sonra gerçekten yavaş olan kısımları optimize etmek en iyi yaklaşımdır.

10. Kod Kalitesinin Sürdürülmesi ve Otomatik Analiz
	•	Statik Kod Analizi Araçları: Belirlenen kod standartlarına uyumu sürekli kılmak için araçlardan faydalanın. Örneğin, StyleCop Analyzers gibi paketler veya .editorconfig ayarları ile projenizde kod stili kurallarını (isimlendirme, boşluk, bracing vs.) otomatik olarak denetleyebilirsiniz. Derleme anında veya CI (Continuous Integration) sürecinde bu kurallar ihlal edildiğinde uyarılar verilecektir. Benzer şekilde, Roslyn Analyzer kütüphaneleri ile kendi takım kurallarınızı dahi tanımlayabilirsiniz.
	•	SonarQube ve Diğer Kalite Araçları: Projenizde SonarQube gibi gelişmiş statik kod analiz araçlarını entegre edin. SonarQube, kodunuzda olası hataları, kod kokularını (code smell), potansiyel güvenlik açıklarını ve standart ihlallerini tarayarak raporlar. Bu tür araçlar yüzlerce kural üzerinden kodu değerlendirdiğinden, takım standartlarınızın uygulandığını doğrulamada yardımcı olur ￼. Örneğin, SonarQube üzerinden “blok içerisinde boşluk kullanımı” veya “magic number kullanımı” gibi pek çok kuralı izleyebilir, zaman içinde metriklerin (ör. döngüsel karmaşıklık, derinlik) sınırlarını aşmadığından emin olabilirsiniz.
	•	Kod İncelemeleri ve Pull Request Kuralları: Otomatik araçların yanı sıra, ekip içinde code review (kod inceleme) süreçleri tanımlayın. Her yeni kod değişikliği (pull request) en az bir ekip üyesi tarafından gözden geçirilerek standartlara uyum, anlaşılabilirlik ve olası hatalar açısından incelenmelidir ￼. Kod incelemelerinde tutarlı bir checklist kullanarak (ör. “isimlendirmeler doğru mu?”, “hata yakalamalar uygun mu?” gibi) kalite standardınızı koruyabilirsiniz.
	•	Sürekli Entegrasyon ve Testler: CI/CD süreçlerinde style ve analysis araçlarını entegre edin. Örneğin, build pipeline’ınıza SonarQube taraması, StyleCop denetimi veya FXCop analizleri ekleyerek geliştiricilerin lokalde kaçırabileceği sorunları yakalayın. Derleme başarısızlık kriterlerine önemli standart ihlallerini dahil edin ki ekip üyeleri düzeltme yapmadan kodu birleştiremesin. Ayrıca, yüksek kaliteli kod demek test edilebilir kod demektir; birim testlerinin yazılmasını teşvik edin ve bu testlerin geçerliliğini CI’da koşarak hem doğruluk hem de belirli ölçüde tasarım kalitesi (SOLID’e uygun gevşek bağlılık gibi) sağlayın.
	•	Dokümantasyon ve Eğitim: Takımdaki tüm geliştiricilerin bu standartları bilmesi ve önemini kavraması gerekir. Yeni başlayan ekip üyelerine kodlama standartları dokümanını iletin, mümkünse örneklerle destekleyin. StyleCop uyarıları veya SonarQube raporlarında sık tekrarlanan ihlaller için kısa bir bilgi paylaşımı yaparak doğrusunu gösterin. Düzenli aralıklarla standartları gözden geçirip gerekiyorsa takım konsensüsüyle güncelleyin. Kod standartları yaşayan bir dokümandır; teknolojideki yeni gelişmelerle (ör. yeni C# dil özellikleri) veya proje ihtiyaçlarıyla evrim geçirebilir.

Kaynaklar: Bu standartlar, Microsoft’un resmi .NET yönergeleri ￼ ￼, C# topluluk önerileri ve yazılım geliştirmede kabul görmüş prensipler (SOLID, Clean Code) temel alınarak hazırlanmıştır. StyleCop, SonarQube gibi araçlar hakkında daha fazla bilgi için Microsoft Docs ve ilgili topluluk dökümanlarına başvurabilirsiniz. Bu kurallara uyarak, ekip içinde tutarlı, bakımı kolay ve yüksek kaliteli C# kodu yazılması hedeflenmektedir.



•	Kod okunabilirliği: Kod standartları, kodun daha kolay okunup anlaşılmasını sağlar. Tutarlı bir format, girintileme ve isimlendirme kullanıldığında, tüm geliştiriciler kodu benzer bir şekilde yazar. Bu sayede bir geliştirici, başka bir ekip üyesinin yazdığı kodu rahatlıkla okuyabilir ve ne yaptığını hızlıca kavrayabilir. “Kod bir kez yazılır ama defalarca okunur” sözünün de işaret ettiği gibi, okunaklı kod geliştirme sürecinde zaman kazandırır ve yanlış anlamaları önler.
	•	Yeni geliştiricilerin adaptasyonu: Kod standartları, ekibe yeni katılan geliştiricilerin kod tabanına hızlıca adapte olmasını sağlar. Projedeki tüm kod benzer kurallar ve stil altında yazıldığında, yeni gelen bir geliştirici kodun yapısını çözmek için gereksiz zaman harcamaz. Standartlar sayesinde projeye özgü alışkanlıklar ve konvansiyonlar net olduğundan, yeni üyeler kendilerini daha güvende hisseder ve çekinmeden katkı sunabilir. Sonuç olarak, yeni ekip üyeleri kısa sürede üretken hale gelerek projeye değer katmaya başlar.
	•	Bakım ve güncelleme kolaylığı: Kod standartları, yazılımın bakımını ve güncellenmesini kolaylaştırır. Standartlara uygun olarak yazılmış kod daha anlaşılır ve düzenli olduğundan, bir özelliği değiştirmek veya bir hatayı düzeltmek gerektiğinde geliştiriciler ilgili kodu hızlıca bulabilir. Tutarlı yapı sayesinde bir değişikliğin diğer bölümlere etkisini anlamak da kolaylaşır. Bu da güncelleme yaparken hata riskini azaltır ve bakım sürecini hızlandırır.
	•	Kod tutarlılığı: Kod standartları, projede yazılan tüm kodun tutarlı olmasını sağlar. Farklı geliştiriciler kod yazsa bile ortak standartlar nedeniyle kod sanki tek bir kişi tarafından yazılmış gibi görünür. Bu tutarlılık, proje içinde bir dosyadan diğerine geçerken geliştiricilerin yabancılık çekmemesini sağlar. Her modülde benzer bir yapı ve adlandırma ile karşılaşmak, kodun anlaşılmasını ve üzerinde çalışılmasını kolaylaştırır. Ayrıca tutarlı bir kod tabanı, kod gözden geçirme ve hata tespit süreçlerini de basitleştirir.
	•	Ekip içi iş birliği: Kod standartları, takım içinde daha iyi bir iş birliği ortamı oluşturur. Tüm ekip üyeleri aynı kodlama kurallarına uyduğunda, adeta “aynı dilde” iletişim kurar gibi kod yazarlar. Bu, ekip içinde yanlış anlaşılmaları en aza indirir ve birlikte çalışma süreçlerini hızlandırır. Kod incelemeleri (code review) daha verimli hale gelir; çünkü tartışmalar kodun stili yerine işlevselliği üzerine odaklanabilir. Sonuç olarak, ekip üyeleri birbirlerinin kodunu rahatlıkla anlayıp üzerinde ortak çalışabilir hale gelir.
	•	Hata ve bugları azaltma: Standartlar, yaygın hataların önüne geçerek yazılımda çıkabilecek hata sayısını azaltır. Kod standartları genellikle en iyi uygulamaları (best practices) içerdiğinden, geliştiriciler bu kurallara uyarak potansiyel hatalardan kaçınır. Örneğin, tutarlı değişken isimlendirmesi veya belirlenmiş bir hata yönetimi deseni sayesinde yanlış değişken kullanımı veya gözden kaçan istisnalar gibi problemler daha az yaşanır. Ayrıca anlaşılır ve düzenli kod, testler ve kod gözden geçirmeler sırasında hataların erken fark edilmesini kolaylaştırır. Bu sayede proje genelinde daha az hata ortaya çıkar ve yazılım kalitesi artar.
	•	Performans ve verimlilik: Kodlama standartlarına uymak, yazılımın performansı ve geliştirme ekibinin verimliliği üzerinde olumlu etki yapar. Standartlar, gereksiz tekrarları önleyip verimli kodlama tekniklerini teşvik ettiği için uygulamanın daha verimli şekilde çalışmasına katkı sağlar. Örneğin, herkesin belirli bir algoritma yapısına veya bellek kullanımı kuralına uyması, olası performans sorunlarını en baştan engelleyebilir. Ekip açısından bakıldığında, standart bir kod yapısı sayesinde geliştiriciler kodu daha hızlı anlayıp yazabilirler. Bu da zaman kazandırır ve ekip genelinde üretkenliği artırır.
	•	Kodun yeniden kullanılabilirliği: Kod standartları, kodun tekrar tekrar kullanılabilen modüller şeklinde yazılmasını teşvik eder. İyi tanımlanmış standartlar, geliştiricileri benzer işlevleri kopyalamak yerine ortak fonksiyonlar veya kütüphaneler oluşturmaya yönlendirir. Bu sayede bir kez yazılan bir kod parçası, ihtiyaç duyulan her yerde tekrar kullanılabilir hale gelir. Aynı işleve sahip kodu yeniden yazmaya gerek kalmaz; böylece zamandan ve efordan tasarruf edilir. Ayrıca, yeniden kullanılabilir kod projenin farklı bölümleri arasında tutarlılığı da artırır.
	•	Test süreçlerini kolaylaştırma: Standartlar sayesinde kodun test edilmesi daha kolay ve etkili hale gelir. Tutarlı ve öngörülebilir bir kod yapısı olduğundan, test senaryolarını oluşturmak ve uygulamak daha az karmaşıktır. Kodlama standartları genellikle fonksiyonların tek bir sorumluluğu olmasını ve modülerliği teşvik eder; bu da birim testlerinin yazılmasını basitleştirir çünkü her bir parça bağımsız olarak test edilebilir. Ayrıca, kod net ve anlaşılır olduğunda, testler sırasında beklenmedik davranışlarla karşılaşma olasılığı da düşer. Böylelikle hem manuel testler hem de otomatik testler daha sorunsuz bir şekilde yürütülebilir.
	•	Uzun vadede sürdürülebilirlik: Kod standartları, bir yazılım projesinin yıllar boyu sürdürülebilir olmasına zemin hazırlar. Ekip üyeleri değişse bile, standartlara göre yazılmış bir kod tabanı yeni gelenler tarafından kolayca anlaşılabilir ve devam ettirilebilir. Teknolojiler veya gereksinimler zaman içinde değiştiğinde, temiz ve düzenli kod bu değişikliklere uyum sağlamayı kolaylaştırır; proje gelişimini kesintisiz sürdürebilir. Buna ek olarak, tutarlı bir yaklaşım teknik borcun (technical debt) birikmesini önleyerek gelecekte büyük çaplı yeniden yazımların veya kapsamlı düzeltmelerin önüne geçer. Uzun vadede, kod standartlarına bağlı kalmak hem bakım maliyetlerini düşürür hem de yazılımın güvenilirliğini artırır.


Kod standartlarının ekip içinde neden önemli olduğunu aşağıdaki maddeler halinde açık1.	Kod Okunabilirliğini Artırır – Standart bir format ile yazılmış kod, tüm ekip üyeleri tarafından kolayca okunabilir ve anlaşılabilir hale gelir.
	2.	Yeni Geliştiricilerin Adaptasyonunu Kolaylaştırır – Ekibe yeni katılan geliştiriciler, belirlenmiş standartları takip ederek projeye daha hızlı uyum sağlar.
	3.	Kodun Bakımını ve Güncellenmesini Kolaylaştırır – Standart bir yapıya sahip kod, ilerleyen zamanlarda hata düzeltme ve yeni özellik ekleme süreçlerini hızlandırır.
	4.	Kod Tutarlılığını Sağlar – Aynı proje içinde farklı yazılımcıların aynı kurallara göre yazılım geliştirmesi, kodda tutarlılık sağlar ve kaosu önler.
	5.	Ekip İçi İş Birliğini Güçlendirir – Ortak standartlar sayesinde ekip içi kod incelemeleri (code review) daha verimli olur ve herkes aynı formatı anlar.
	6.	Hata ve Bugları Azaltır – Belirli kurallar ve standartlar, kötü kod yazımını önleyerek hata olasılığını düşürür.
	7.	Performansı ve Verimliliği Artırır – Temiz ve düzenli kod, geliştirme sürecini hızlandırır ve gereksiz tekrarları önleyerek ekip verimliliğini artırır.
	8.	Kodun Yeniden Kullanılabilirliğini Artırır – Standartlara uygun yazılmış kod parçaları başka projelerde veya modüllerde kolayca tekrar kullanılabilir.
	9.	Test Süreçlerini Kolaylaştırır – Düzenli ve belirli kurallara göre yazılmış kod, test edilmesi ve otomatik testler ile entegre edilmesi daha kolay hale gelir.
	10.	Kodun Uzun Vadede Sürdürülebilir Olmasını Sağlar – Standartlara uygun kod, zamanla değişen ekip üyeleri ve teknoloji gereksinimleri karşısında daha dayanıklı olur.

Bu noktalar, ekip içindeki yazılım geliştirme sürecini daha verimli, kaliteli ve sürdürülebilir hale getirmek için kod standartlarının ne kadar önemli olduğunu vurgular.

protected override void OnResize(EventArgs e)
{
    base.OnResize(e);
    UpdateFormColors();
}

private void UpdateFormColors()
{
    if (this.ContainsFocus || WindowState != FormWindowState.Minimized)
    {
        // Form odaklanmışsa veya minimize edilmemişse
        ApplyActiveColors();
    }
    else
    {
        // Form odaklanmamışsa veya minimize edilmişse
        ApplyInactiveColors();
    }
}

private void ApplyActiveColors()
{
    // Aktifken uygulanan renkler
    using (LinearGradientBrush lgb = new LinearGradientBrush(ClientRectangle, Color.DeepSkyBlue, Color.MidnightBlue, LinearGradientMode.Vertical))
    {
        Graphics g = CreateGraphics();
        g.FillRectangle(lgb, ClientRectangle);
    }
}

private void ApplyInactiveColors()
{
    // Pasifken uygulanan renkler
    using (LinearGradientBrush lgb = new LinearGradientBrush(ClientRectangle, Color.Gray, Color.DarkGray, LinearGradientMode.Vertical))
    {
        Graphics g = CreateGraphics();
        g.FillRectangle(lgb, ClientRectangle);
    }
}



using System;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;

public class CustomButton : Button
{
    private Color hoverBackColor = Color.Gray;
    private Color clickEffectColor = Color.DarkGray;
    private int borderRadius = 0;
    private int borderSize = 2;
    private Color borderColor = Color.Black;
    private int animationDuration = 100;
    private int cornerRadius = 20;

    public CustomButton()
    {
        FlatStyle = FlatStyle.Flat;
        FlatAppearance.BorderSize = borderSize;
        FlatAppearance.BorderColor = borderColor;
    }

    [Category("Appearance"), Description("Arka planın hover rengi.")]
    public Color HoverBackColor
    {
        get { return hoverBackColor; }
        set { hoverBackColor = value; Invalidate(); }
    }

    [Category("Appearance"), Description("Tıklama efektinin rengi.")]
    public Color ClickEffectColor
    {
        get { return clickEffectColor; }
        set { clickEffectColor = value; Invalidate(); }
    }

    [Category("Appearance"), Description("Butonun kenarlık kalınlığı.")]
    public int BorderSize
    {
        get { return borderSize; }
        set { borderSize = value; FlatAppearance.BorderSize = borderSize; Invalidate(); }
    }

    [Category("Appearance"), Description("Butonun kenarlık rengi.")]
    public Color BorderColor
    {
        get { return borderColor; }
        set { borderColor = value; FlatAppearance.BorderColor = borderColor; Invalidate(); }
    }

    [Category("Behavior"), Description("Animasyon süresi (milisaniye).")]
    public int AnimationDuration
    {
        get { return animationDuration; }
        set { animationDuration = value; Invalidate(); }
    }

    [Category("Appearance"), Description("Buton köşelerinin yuvarlaklık derecesi.")]
    public int CornerRadius
    {
        get { return cornerRadius; }
        set { cornerRadius = value; Invalidate(); }
    }

    [Category("Appearance"), Description("Butonun yuvarlak olup olmaması.")]
    public bool IsCircular
    {
        get { return borderRadius > Height / 2; }
        set { borderRadius = value ? Height / 2 : 0; Invalidate(); }
    }

    protected override void OnPaint(PaintEventArgs pevent)
    {
        base.OnPaint(pevent);
        pevent.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
        Rectangle rectSurface = ClientRectangle;
        Rectangle 
